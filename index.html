<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixelruud - Every pixel of your ride | Gravel Route Planner</title>
    <meta name="description" content="Pixelruud: Pixel-perfect gravel bike route planning with X-Ray Magnifier, precise elevation data, and surface analysis. Your gravel companion.">
    <meta name="keywords" content="gravel bike, route planner, cycling, elevation, surface analysis, GPX, bikepacking">
    <meta name="author" content="Pixelruud">
    
    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pixelruud.com/">
    <meta property="og:title" content="Pixelruud - Every pixel of your ride">
    <meta property="og:description" content="Pixel-perfect gravel bike route planning with X-Ray Magnifier technology. Your gravel companion.">
    <meta property="og:image" content="https://pixelruud.com/og-image.jpg">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://pixelruud.com/">
    <meta property="twitter:title" content="Pixelruud - Every pixel of your ride">
    <meta property="twitter:description" content="Pixel-perfect gravel bike route planning with X-Ray Magnifier technology.">
    <meta property="twitter:image" content="https://pixelruud.com/og-image.jpg">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; height: 100vh; display: flex; flex-direction: column; }
        #map { flex: 1; width: 100%; }
        #loadingMessage { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 24px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.16); z-index: 10000; }
        .control-panel { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(255,255,255,0.9); backdrop-filter: blur(20px); padding: 10px 14px; box-shadow: 0 -8px 32px rgba(0,0,0,0.08); border-top: 1px solid rgba(255,255,255,0.5); display: flex; flex-wrap: nowrap; gap: 8px; align-items: center; overflow-x: auto; z-index: 1000; }
        .btn { 
            padding: 8px 12px; 
            border: none; 
            border-radius: 10px; 
            cursor: pointer; 
            font-size: 11px; 
            font-weight: 600; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            white-space: nowrap; 
            position: relative;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 
                        0 1px 2px rgba(0,0,0,0.08),
                        inset 0 1px 0 rgba(255,255,255,0.15),
                        inset 0 -1px 0 rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
            transition: left 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .btn::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px;
            padding: 1px;
            background: linear-gradient(145deg, rgba(255,255,255,0.4), rgba(255,255,255,0.05));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.18),
                        0 2px 4px rgba(0,0,0,0.12),
                        inset 0 1px 0 rgba(255,255,255,0.25),
                        inset 0 -1px 0 rgba(0,0,0,0.15);
        }
        
        .btn:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2),
                        inset 0 2px 4px rgba(0,0,0,0.15);
        }
        
        .btn-primary { 
            background: linear-gradient(145deg, #4f8fff 0%, #2563eb 100%); 
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .btn-primary:hover {
            background: linear-gradient(145deg, #60a5fa 0%, #3b82f6 100%);
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.45),
                        0 4px 8px rgba(59, 130, 246, 0.3),
                        inset 0 1px 0 rgba(255,255,255,0.35);
        }
        
        .btn-secondary { 
            background: linear-gradient(145deg, #7c8fa5 0%, #475569 100%); 
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .btn-secondary:hover {
            background: linear-gradient(145deg, #8b9eb3 0%, #64748b 100%);
            box-shadow: 0 8px 24px rgba(100, 116, 139, 0.45),
                        0 4px 8px rgba(100, 116, 139, 0.3),
                        inset 0 1px 0 rgba(255,255,255,0.35);
        }
        
        .btn-danger { 
            background: linear-gradient(145deg, #f87171 0%, #dc2626 100%); 
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .btn-danger:hover {
            background: linear-gradient(145deg, #fca5a5 0%, #ef4444 100%);
            box-shadow: 0 8px 24px rgba(239, 68, 68, 0.45),
                        0 4px 8px rgba(239, 68, 68, 0.3),
                        inset 0 1px 0 rgba(255,255,255,0.35);
        }
        
        .btn-success { 
            background: linear-gradient(145deg, #34d399 0%, #059669 100%); 
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .btn-success:hover {
            background: linear-gradient(145deg, #6ee7b7 0%, #10b981 100%);
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.45),
                        0 4px 8px rgba(16, 185, 129, 0.3),
                        inset 0 1px 0 rgba(255,255,255,0.35);
        }
        
        .btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
        }
        
        .btn:disabled:hover {
            transform: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
        }
        
        .btn svg {
            width: 16px;
            height: 16px;
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.15));
        }
        .waypoint-list { max-height: 60px; overflow-y: auto; background: rgba(255,255,255,0.8); backdrop-filter: blur(10px); border-radius: 12px; padding: 5px; border: 1px solid rgba(226,232,240,0.8); min-width: 180px; }
        .waypoint-item { display: flex; align-items: center; gap: 6px; padding: 3px 6px; background: #f8fafc; margin: 2px 0; border-radius: 6px; font-size: 11px; }
        .waypoint-number { background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; width: 18px; height: 18px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 10px; }
        .waypoint-coords { flex: 1; color: #475569; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .waypoint-remove { cursor: pointer; color: #ef4444; font-weight: bold; padding: 0 4px; border-radius: 4px; }
        .stats-panel { 
            position: absolute; 
            top: 42px; 
            left: 58px; 
            background: rgba(255,255,255,0.85); 
            backdrop-filter: blur(20px); 
            padding: 8px 12px 12px 12px; 
            border-radius: 0 12px 12px 12px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.12); 
            border: 1px solid rgba(255,255,255,0.5); 
            z-index: 1000; 
            min-width: 180px; 
            max-width: 200px; 
            transition: opacity 0.3s ease, transform 0.3s ease; 
            display: none; 
        }
        .stats-panel.show { display: block; }
        .stats-panel.faded { opacity: 0.3; }
        
        .stats-tab {
            position: absolute;
            top: 12px;
            left: 58px;
            background: rgba(241, 245, 249, 0.8);
            backdrop-filter: blur(10px);
            padding: 6px 12px;
            border-radius: 8px 8px 0 0;
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-bottom: none;
            z-index: 1001;
            cursor: pointer;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.05);
            font-size: 10px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.2s ease;
            display: none;
            white-space: nowrap;
        }
        
        .stats-tab.show {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .stats-tab:hover {
            background: rgba(255, 255, 255, 0.95);
            color: #3b82f6;
        }
        
        .stats-tab.active {
            background: rgba(255, 255, 255, 0.85);
            color: #3b82f6;
            font-weight: 700;
            border-color: rgba(255, 255, 255, 0.5);
        }
        .stats-panel h3 { margin: 0 0 6px 0; font-size: 12px; color: #0f172a; font-weight: 700; }
        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f1f5f9; font-size: 10px; gap: 6px; }
        .stat-label { color: #64748b; font-weight: 500; white-space: nowrap; }
        .stat-value { font-weight: 700; color: #0f172a; white-space: nowrap; }
        .stats-highlight { background: linear-gradient(135deg, #eff6ff, #dbeafe); padding: 8px; border-radius: 8px; margin: 5px 0; border-left: 3px solid #3b82f6; }
        .stats-highlight .stat-item { border: none; padding: 2px 0; }
        .profile-selector { display: flex; gap: 3px; background: rgba(241,245,249,0.8); backdrop-filter: blur(10px); padding: 4px; border-radius: 10px; border: 1px solid rgba(226,232,240,0.8); }
        .profile-btn { 
            padding: 6px 10px; 
            border: none; 
            background: transparent; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 10px; 
            font-weight: 600; 
            color: #64748b; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .profile-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59,130,246,0.15), transparent);
            transition: left 0.5s;
        }
        
        .profile-btn:hover::before {
            left: 100%;
        }
        
        .profile-btn:hover {
            background: rgba(255,255,255,0.6);
            color: #475569;
        }
        
        .profile-btn.active { 
            background: linear-gradient(145deg, #ffffff, #f8fafc); 
            color: #3b82f6; 
            box-shadow: 0 4px 12px rgba(59,130,246,0.2),
                        0 2px 4px rgba(0,0,0,0.08),
                        inset 0 1px 0 rgba(255,255,255,0.9),
                        inset 0 -1px 0 rgba(59,130,246,0.1);
            transform: translateY(-1px);
        }
        
        /* Elevation Preference Styles */
        .elevation-preference {
            display: flex;
            gap: 6px;
        }
        
        .elevation-pref-btn {
            flex: 1;
            padding: 6px 8px;
            background: linear-gradient(145deg, #f1f5f9, #e2e8f0);
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-radius: 8px;
            cursor: pointer;
            font-size: 9px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08),
                        inset 0 1px 0 rgba(255,255,255,0.15),
                        inset 0 -1px 0 rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .elevation-pref-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        .elevation-pref-btn:hover::before {
            left: 100%;
        }
        
        .elevation-pref-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15),
                        inset 0 1px 0 rgba(255,255,255,0.2);
            border-color: #3b82f6;
        }
        
        .elevation-pref-btn.active {
            background: linear-gradient(145deg, #3b82f6, #2563eb);
            color: white;
            border-color: #2563eb;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4),
                        inset 0 1px 0 rgba(255,255,255,0.2);
        }
        
        .elevation-pref-btn .pref-icon {
            font-size: 16px;
        }
        
        .elevation-pref-btn .pref-label {
            font-size: 9px;
        }
        
        /* API Settings Styles */
        .api-settings-toggle {
            position: absolute;
            top: 12px;
            right: 180px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            z-index: 1001;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.3s ease;
        }
        
        .api-settings-toggle:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #3b82f6;
            color: #3b82f6;
            transform: translateX(-3px);
        }
        
        /* GPX Import Button */
        .gpx-import-toggle {
            position: absolute;
            top: 52px;
            right: 180px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            z-index: 1001;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.3s ease;
        }
        
        .gpx-import-toggle:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #10b981;
            color: #10b981;
            transform: translateX(-3px);
        }
        
        .gpx-import-input {
            display: none;
        }
        
        .api-settings-panel {
            position: absolute;
            top: 12px;
            right: 238px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(20px);
            padding: 16px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            border: 1px solid rgba(255,255,255,0.5);
            z-index: 1000;
            width: 300px;
            display: none;
        }
        
        .api-settings-panel.show {
            display: block;
        }
        
        .api-settings-panel h4 {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: #0f172a;
            font-weight: 700;
        }
        
        .api-key-input {
            margin-bottom: 12px;
        }
        
        .api-key-input label {
            display: block;
            font-size: 10px;
            color: #64748b;
            margin-bottom: 4px;
            font-weight: 600;
        }
        
        .api-key-input input {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-radius: 8px;
            font-size: 11px;
            font-family: monospace;
            background: rgba(255,255,255,0.9);
        }
        
        .api-key-input input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .api-save-btn {
            width: 100%;
            padding: 8px;
            background: linear-gradient(145deg, #3b82f6, #2563eb);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }
        
        .api-save-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
        }
        
        .api-info {
            font-size: 9px;
            color: #64748b;
            margin-top: 8px;
            line-height: 1.4;
        }
        
        .speed-control { display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.8); backdrop-filter: blur(10px); padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(226,232,240,0.8); min-width: 150px; }
        .speed-control label { font-size: 10px; color: #64748b; font-weight: 600; white-space: nowrap; }
        .speed-slider { flex: 1; height: 6px; border-radius: 3px; background: linear-gradient(to right, #e2e8f0, #cbd5e1); outline: none; -webkit-appearance: none; }
        .speed-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: linear-gradient(145deg, #60a5fa, #3b82f6); cursor: pointer; border: 2px solid white; }
        .speed-value { font-weight: 700; color: #3b82f6; font-size: 10px; min-width: 40px; text-align: right; }
        .loading { display: none; color: #3b82f6; font-weight: 600; font-size: 12px; }
        .loading.show { display: flex; }
        
        /* POI Toggle Styles */
        .poi-toggle {
            position: absolute;
            bottom: 320px;
            right: 12px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 8px;
            border-radius: 10px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .poi-toggle.faded {
            opacity: 0.4;
            transform: translateX(5px) scale(0.95);
        }
        
        .poi-btn {
            padding: 6px 10px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
        }
        
        .poi-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59,130,246,0.2), transparent);
            transition: left 0.5s;
        }
        
        .poi-btn:hover::before {
            left: 100%;
        }
        
        .poi-btn:hover {
            background: rgba(59, 130, 246, 0.12);
            transform: translateX(2px);
        }
        
        .poi-btn.active {
            background: linear-gradient(145deg, #3b82f6, #2563eb);
            color: white;
            box-shadow: 0 3px 10px rgba(59, 130, 246, 0.5),
                        inset 0 1px 0 rgba(255,255,255,0.3),
                        inset 0 -1px 0 rgba(0,0,0,0.1);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        /* Address Search Styles */
        .address-search {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px;
            border-radius: 12px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 240px;
            max-width: 280px;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .address-search.faded {
            opacity: 0.4;
            transform: translateX(-50%) scale(0.95);
        }
        
        .address-input {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 13px;
            outline: none;
            transition: all 0.2s;
        }
        
        .address-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .address-results {
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
        
        .address-results.show {
            display: block;
        }
        
        .address-result-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.15s;
            border-bottom: 1px solid #f1f5f9;
        }
        
        .address-result-item:hover {
            background: #eff6ff;
        }
        
        .address-result-item:last-child {
            border-bottom: none;
        }
        
        .search-btn {
            padding: 8px 12px;
            background: linear-gradient(145deg, #3b82f6, #2563eb);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .search-btn:hover {
            background: linear-gradient(145deg, #2563eb, #1d4ed8);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        /* ========================================
           X-RAY MAGNIFIER PRO - FIXED VERSION
           ======================================== */
        
        /* Container - AUSSERHALB von Leaflet's z-index System */
        .magnifier-container {
            position: fixed !important;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none !important;
            z-index: 999999 !important;
        }
        
        /* X-RAY MAGNIFIER - Pro Version */
        .magnifier {
            position: absolute !important;
            width: 250px;
            height: 250px;
            border: 4px solid;
            border-image: linear-gradient(135deg, #3b82f6, #8b5cf6, #ec4899) 1;
            border-radius: 50%;
            pointer-events: none !important;
            z-index: 1 !important;
            display: none;
            overflow: hidden;
            box-shadow: 0 12px 48px rgba(0,0,0,0.4),
                        inset 0 0 30px rgba(59, 130, 246, 0.2),
                        0 0 0 2px rgba(255,255,255,0.8),
                        0 0 20px rgba(59, 130, 246, 0.6);
            background: white;
            animation: magnifier-pulse 3s ease-in-out infinite;
        }
        
        /* CRITICAL: Ensure ALL children of magnifier have no pointer events */
        .magnifier * {
            pointer-events: none !important;
        }
        
        @keyframes magnifier-pulse {
            0%, 100% { box-shadow: 0 12px 48px rgba(0,0,0,0.4), 0 0 20px rgba(59, 130, 246, 0.6); }
            50% { box-shadow: 0 16px 56px rgba(0,0,0,0.5), 0 0 30px rgba(139, 92, 246, 0.8); }
        }
        
        .magnifier.frozen {
            border-color: #f59e0b;
            animation: none;
            box-shadow: 0 12px 48px rgba(0,0,0,0.4), 0 0 30px rgba(245, 158, 11, 0.8);
        }
        
        /* Crosshair - High-Tech Style */
        .magnifier::before,
        .magnifier::after {
            content: '';
            position: absolute;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.8), transparent);
            z-index: 2;
            pointer-events: none;
        }
        
        .magnifier::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.8);
        }
        
        .magnifier::after {
            top: 50%;
            left: 0;
            height: 2px;
            width: 100%;
            transform: translateY(-50%);
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.8);
        }
        
        /* Info Overlays */
        .magnifier-coords {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(15px);
            color: #00ff00;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            z-index: 10002;
            white-space: nowrap;
            border: 2px solid rgba(0, 255, 0, 0.6);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.8),
                        0 0 15px rgba(0, 255, 0, 0.4);
            pointer-events: none;
            text-shadow: 0 0 8px rgba(0, 255, 0, 0.8),
                        0 2px 4px rgba(0, 0, 0, 1);
        }
        
        .magnifier-elevation {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(15px);
            color: #00d9ff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            z-index: 10002;
            white-space: nowrap;
            border: 2px solid rgba(0, 217, 255, 0.6);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.8),
                        0 0 15px rgba(0, 217, 255, 0.4);
            pointer-events: none;
            text-shadow: 0 0 8px rgba(0, 217, 255, 0.8),
                        0 2px 4px rgba(0, 0, 0, 1);
        }
        
        .magnifier-surface {
            position: absolute;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(15px);
            color: #ff6b00;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            z-index: 10002;
            white-space: nowrap;
            border: 2px solid rgba(255, 107, 0, 0.6);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.8),
                        0 0 15px rgba(255, 107, 0, 0.4);
            pointer-events: none;
            text-shadow: 0 0 8px rgba(255, 107, 0, 0.8),
                        0 2px 4px rgba(0, 0, 0, 1);
        }
        
        .magnifier-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            z-index: 10003;
            display: none;
            animation: pulse 1s ease-in-out infinite;
            pointer-events: none;
        }
        
        .magnifier-loading.show {
            display: block;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .magnifier-map {
            position: absolute;
            width: 500px;
            height: 500px;
            pointer-events: none !important;
        }
        
        /* CRITICAL: Disable pointer events for ALL children of magnifier */
        .magnifier-map * {
            pointer-events: none !important;
        }
        
        .magnifier-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            pointer-events: none !important;
        }
        
        /* Mini Profile */
        .magnifier-mini-profile {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            pointer-events: none !important;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            display: none;
            z-index: 10004;
        }
        
        /* Measure Tool */
        .magnifier-measure-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none !important;
            z-index: 10005;
        }
        
        .measure-line {
            position: absolute;
            background: rgba(239, 68, 68, 0.8);
            transform-origin: 0 0;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);
            height: 3px;
        }
        
        .measure-label {
            position: absolute;
            background: rgba(239, 68, 68, 0.98);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.6),
                        0 0 15px rgba(239, 68, 68, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.8);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }
        
        /* Toggle Button - High-Tech */
        .magnifier-toggle {
            position: fixed !important;
            bottom: 340px;
            left: 12px;
            background: linear-gradient(145deg, #60a5fa, #3b82f6);
            backdrop-filter: blur(10px);
            padding: 14px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.9);
            z-index: 1000;
            cursor: move;
            box-shadow: 0 6px 24px rgba(59, 130, 246, 0.4),
                        inset 0 2px 0 rgba(255,255,255,0.4),
                        inset 0 -2px 0 rgba(0,0,0,0.2);
            width: 54px;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: icon-pulse 2s ease-in-out infinite;
            user-select: none;
        }
        
        @keyframes icon-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .magnifier-toggle::before {
            display: none; /* Vereinfacht */
        }
        
        .magnifier-toggle-icon {
            font-size: 26px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            z-index: 1;
            pointer-events: none;
        }
        
        .magnifier-toggle:hover {
            background: linear-gradient(145deg, #3b82f6, #2563eb);
            transform: scale(1.15) rotate(15deg);
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.6),
                        inset 0 2px 0 rgba(255,255,255,0.5);
        }
        
        .magnifier-toggle.dragging {
            cursor: grabbing !important;
            transform: scale(1.1);
            opacity: 0.85;
            animation: none;
            z-index: 10000;
        }
        
        .magnifier-toggle.active {
            background: linear-gradient(145deg, #8b5cf6, #7c3aed);
            border-color: #a78bfa;
            box-shadow: 0 8px 32px rgba(139, 92, 246, 0.6),
                        inset 0 2px 0 rgba(255,255,255,0.5);
            animation: icon-pulse 1s ease-in-out infinite;
        }
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.6),
                        inset 0 2px 0 rgba(255,255,255,0.3),
                        0 0 20px rgba(139, 92, 246, 0.5);
            transform: scale(1.05);
        }
        
        .magnifier-toggle.active .magnifier-toggle-icon {
            animation: pulse-icon 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-icon {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* Settings Panel */
        .magnifier-settings {
            position: absolute;
            bottom: 240px;
            right: 12px;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            padding: 16px;
            border-radius: 16px;
            border: 2px solid rgba(59, 130, 246, 0.3);
            z-index: 10001;
            min-width: 280px;
            max-width: 320px;
            box-shadow: 0 12px 48px rgba(0,0,0,0.4),
                        inset 0 1px 0 rgba(255,255,255,0.1),
                        0 0 20px rgba(59, 130, 246, 0.3);
            display: none;
            color: white;
            cursor: move;
            user-select: none;
        }
        
        .magnifier-settings.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }
        
        .magnifier-settings.dragging {
            cursor: grabbing !important;
            opacity: 0.9;
            z-index: 10005;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6),
                        inset 0 1px 0 rgba(255,255,255,0.1),
                        0 0 30px rgba(59, 130, 246, 0.5);
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .magnifier-settings h4 {
            margin: 0 0 12px 0;
            font-size: 13px;
            font-weight: 700;
            color: #60a5fa;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: move;
            padding: 4px 0;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            padding-bottom: 8px;
            margin-bottom: 16px;
        }
        
        .magnifier-settings h4::after {
            content: '⋮⋮';
            margin-left: auto;
            opacity: 0.5;
            font-size: 16px;
            letter-spacing: -2px;
        }
        
        .magnifier-settings h4:hover::after {
            opacity: 1;
        }
        
        .magnifier-setting-group {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .magnifier-setting-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .magnifier-setting-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: #94a3b8;
            margin-bottom: 6px;
            font-weight: 600;
            cursor: default;
        }
        
        .magnifier-setting-value {
            color: #60a5fa;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .magnifier-slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(90deg, #1e293b, #334155);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }
        
        .magnifier-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #60a5fa, #3b82f6);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
            transition: all 0.2s;
        }
        
        .magnifier-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.8);
        }
        
        .magnifier-mode-select {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 6px;
        }
        
        .magnifier-mode-btn {
            padding: 6px 8px;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            color: #94a3b8;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        
        .magnifier-mode-btn:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: #3b82f6;
            color: #60a5fa;
        }
        
        .magnifier-mode-btn.active {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-color: #2563eb;
            color: white;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }
        
        .magnifier-feature-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 8px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .magnifier-feature-toggle:hover {
            background: rgba(59, 130, 246, 0.1);
        }
        
        .magnifier-feature-label {
            font-size: 10px;
            color: #cbd5e1;
            font-weight: 500;
        }
        
        .magnifier-toggle-switch {
            width: 36px;
            height: 18px;
            background: rgba(71, 85, 105, 0.8);
            border-radius: 9px;
            position: relative;
            transition: all 0.3s;
        }
        
        .magnifier-toggle-switch::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #475569;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }
        
        .magnifier-feature-toggle.active .magnifier-toggle-switch {
            background: linear-gradient(90deg, #3b82f6, #2563eb);
        }
        
        .magnifier-feature-toggle.active .magnifier-toggle-switch::after {
            left: 20px;
            background: white;
        }
        
        .magnifier-settings-toggle {
            position: absolute;
            bottom: 240px;
            right: 12px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            z-index: 1000;
            cursor: move;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            font-size: 10px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.3s ease;
            display: none;
            user-select: none;
        }
        
        .magnifier-settings-toggle.show {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .magnifier-settings-toggle:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #3b82f6;
            color: #3b82f6;
            transform: translateX(-3px);
        }
        
        .magnifier-settings-toggle.dragging {
            cursor: grabbing !important;
            opacity: 0.85;
            z-index: 10000;
        }
        
        /* Route Library Styles */
        .route-library {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            min-width: 250px;
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
            transition: opacity 0.3s ease;
        }
        
        .route-library.show {
            display: block;
        }
        
        .route-library.faded {
            opacity: 0.4;
        }
        
        .route-library-close {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.1);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .route-library-close:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: scale(1.1);
        }
        
        .route-library-close svg {
            width: 14px;
            height: 14px;
            color: #ef4444;
        }
        
        .route-library h4 {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #0f172a;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .route-item {
            padding: 8px;
            margin: 6px 0;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .route-item:hover {
            background: #eff6ff;
            border-color: #3b82f6;
            transform: translateX(3px);
        }
        
        .route-item-name {
            font-weight: 600;
            font-size: 12px;
            color: #0f172a;
            margin-bottom: 4px;
        }
        
        .route-item-stats {
            font-size: 10px;
            color: #64748b;
            display: flex;
            justify-content: space-between;
        }
        
        .route-item-count {
            background: linear-gradient(145deg, #3b82f6, #2563eb);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: 600;
        }
        
        .route-item-actions {
            display: flex;
            gap: 4px;
            margin-top: 6px;
        }
        
        .route-item-btn {
            flex: 1;
            padding: 4px 8px;
            font-size: 10px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .route-item-btn.load {
            background: linear-gradient(145deg, #3b82f6, #2563eb);
            color: white;
        }
        
        .route-item-btn.delete {
            background: linear-gradient(145deg, #ef4444, #dc2626);
            color: white;
        }
        
        .library-toggle {
            position: absolute;
            top: 92px;
            right: 180px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            z-index: 1000;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .library-toggle.faded {
            opacity: 0.4;
            transform: translateX(5px) scale(0.95);
        }
        
        .library-toggle:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #3b82f6;
            color: #3b82f6;
            transform: translateX(-3px);
            opacity: 1 !important;
        }
        
        .library-stats {
            background: #f8fafc;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 10px;
        }
        
        .library-stats-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            color: #64748b;
        }
        
        .library-stats-value {
            font-weight: 700;
            color: #3b82f6;
        }
        
        .heatmap-toggle {
            padding: 6px 10px;
            background: linear-gradient(145deg, #f59e0b, #d97706);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            width: 100%;
            margin-top: 8px;
            transition: all 0.3s;
        }
        
        .heatmap-toggle:hover {
            background: linear-gradient(145deg, #fbbf24, #f59e0b);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }
        
        .heatmap-toggle.active {
            background: linear-gradient(145deg, #10b981, #059669);
        }
        
        /* Elevation Profile Styles */
        .elevation-profile {
            position: absolute;
            bottom: 95px;
            left: 12px;
            right: 12px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 12px 12px 12px 12px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            z-index: 1001;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            height: 140px;
            display: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .elevation-profile.show {
            display: block;
        }
        
        .elevation-profile.faded {
            opacity: 0.3;
        }
        
        .elevation-tab {
            position: absolute;
            bottom: 235px;
            left: 12px;
            background: rgba(241, 245, 249, 0.8);
            backdrop-filter: blur(10px);
            padding: 6px 12px;
            border-radius: 8px 8px 0 0;
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-bottom: none;
            z-index: 1002;
            cursor: pointer;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.05);
            font-size: 10px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.2s ease;
            display: none;
            white-space: nowrap;
        }
        
        .elevation-tab.show {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .elevation-tab:hover {
            background: rgba(255, 255, 255, 0.95);
            color: #3b82f6;
        }
        
        .elevation-tab.active {
            background: rgba(255, 255, 255, 0.95);
            color: #3b82f6;
            font-weight: 700;
            border-color: rgba(226, 232, 240, 0.8);
        }
        
        .chart-toggles {
            display: flex;
            gap: 4px;
            margin-bottom: 2px;
            justify-content: center;
        }
        
        .chart-toggle-btn {
            padding: 4px 10px;
            background: rgba(241, 245, 249, 0.6);
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-radius: 6px;
            cursor: pointer;
            font-size: 9px;
            font-weight: 600;
            color: #64748b;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        
        .chart-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: #3b82f6;
            color: #3b82f6;
        }
        
        .chart-toggle-btn.active {
            background: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6;
            color: #3b82f6;
            font-weight: 700;
        }
        
        #elevationChart {
            width: 100%;
            height: 140px;
            position: relative;
        }
        
        /* Engine Selector */
        .engine-selector {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px;
            border-radius: 12px;
            margin: 12px 0;
            border: 2px solid rgba(59, 130, 246, 0.2);
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }

        .engine-label {
            font-size: 11px;
            font-weight: 700;
            color: #64748b;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .engine-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .engine-btn {
            flex: 1;
            min-width: 70px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid rgba(226, 232, 240, 0.8);
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .engine-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6;
            color: #3b82f6;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.2);
        }

        .engine-btn.active {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-color: #3b82f6;
            color: white;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .engine-btn[data-engine="direct"].active {
            background: linear-gradient(135deg, #f97316, #ea580c);
            border-color: #f97316;
        }

        .engine-status {
            font-size: 10px;
            color: #64748b;
            padding: 6px 8px;
            background: rgba(241, 245, 249, 0.8);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
        }

        .engine-status.using {
            color: #10b981;
            font-weight: 600;
        }

        .engine-status.direct {
            color: #f97316;
            font-weight: 600;
        }
        
        /* Segment Context Menu */
        .segment-menu {
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            min-width: 180px;
        }
        
        .segment-menu-title {
            font-size: 11px;
            font-weight: 700;
            color: #64748b;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .segment-menu-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }
        
        .segment-menu-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6;
            color: #3b82f6;
        }
        
        .segment-menu-btn.active {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-color: #3b82f6;
            color: white;
        }
    </style>
    
    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Plausible Analytics (Privacy-First) -->
    <script defer data-domain="pixelruud.com" src="https://plausible.io/js/script.js"></script>
</head>
<body>
    <div id="loadingMessage">Lade Karte...</div>
    <div id="map"></div>
    
    <!-- MAGNIFIER CONTAINER - AUSSERHALB DER MAP -->
    <div class="magnifier-container">
        <div class="magnifier" id="magnifier">
            <div class="magnifier-map" id="magnifierMap"></div>
            <canvas class="magnifier-canvas" id="magnifierCanvas"></canvas>
            <div class="magnifier-coords" id="magnifierCoords">0.00000°, 0.00000°</div>
            <div class="magnifier-elevation" id="magnifierElevation">0m</div>
            <div class="magnifier-surface" id="magnifierSurface">Surface</div>
            <canvas class="magnifier-mini-profile" id="magnifierMiniProfile" width="250" height="40"></canvas>
            <div class="magnifier-measure-overlay" id="magnifierMeasure" style="display: none;">
                <div class="measure-line"></div>
                <div class="measure-label">0.0 km</div>
            </div>
            <div class="magnifier-loading" id="magnifierLoading">🔄</div>
        </div>
    </div>
    
    <!-- Stats Tab Button -->
    <div class="stats-tab" id="statsToggle" title="Statistiken ein/ausblenden">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px;">
            <line x1="18" y1="20" x2="18" y2="10"></line>
            <line x1="12" y1="20" x2="12" y2="4"></line>
            <line x1="6" y1="20" x2="6" y2="14"></line>
        </svg>
        Stats
    </div>
    
    <!-- API Settings Toggle -->
    <div class="api-settings-toggle" id="apiSettingsToggle" title="API Einstellungen">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px; display: inline-block; vertical-align: middle;">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M12 1v6m0 6v6m-9-9h6m6 0h6"></path>
        </svg>
        API
    </div>
    
    <!-- GPX Import Button -->
    <div class="gpx-import-toggle" id="gpxImportToggle" title="GPX-Route importieren">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px; display: inline-block; vertical-align: middle;">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        Import
    </div>
    <input type="file" id="gpxImportInput" class="gpx-import-input" accept=".gpx" />
    
    <!-- API Settings Panel -->
    <div class="api-settings-panel" id="apiSettingsPanel">
        <h4>🔑 API Einstellungen</h4>
        <div class="api-key-input">
            <label>GraphHopper API Key (optional)</label>
            <input type="text" id="graphhopperKeyInput" placeholder="Dein API Key">
            <div class="api-info">Kostenlos: <a href="https://graphhopper.com/dashboard/" target="_blank">graphhopper.com/dashboard</a></div>
        </div>
        <div class="api-key-input">
            <label>Valhalla API Key (optional)</label>
            <input type="text" id="valhallaKeyInput" placeholder="Dein API Key">
            <div class="api-info">Hinweis: Öffentliche Instanz benötigt meist keinen Key</div>
        </div>
        <button class="api-save-btn" id="apiSaveBtn">💾 Speichern</button>
        <div class="api-info" style="margin-top: 12px;">
            API Keys werden lokal im Browser gespeichert. Ohne Keys werden nur BRouter und OSRM verwendet.
        </div>
    </div>
    
    <div class="stats-panel" id="statsPanel">
        <h3>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px; display: inline-block; vertical-align: middle;">
                <line x1="18" y1="20" x2="18" y2="10"></line>
                <line x1="12" y1="20" x2="12" y2="4"></line>
                <line x1="6" y1="20" x2="6" y2="14"></line>
            </svg>
            Statistiken
        </h3>
        <div id="statsContent"></div>
    </div>
    
    <!-- Address Search Panel -->
    <div class="address-search" id="addressSearch">
        <input type="text" 
               class="address-input" 
               id="addressInput" 
               placeholder="Adresse suchen..."
               autocomplete="off"
               style="padding-left: 32px; background-image: url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2216%22 height=%2216%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22%2364748b%22 stroke-width=%222%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22><circle cx=%2211%22 cy=%2211%22 r=%228%22/><path d=%22m21 21-4.35-4.35%22/></svg>'); background-repeat: no-repeat; background-position: 8px center;">
        <div class="address-results" id="addressResults"></div>
    </div>
    
    <!-- POI Toggle Panel -->
    <div class="poi-toggle" id="poiToggle">
        <button class="poi-btn" id="waterBtn" title="Trinkwasserbrunnen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px;">
                <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
            </svg>
            Wasser
        </button>
        <button class="poi-btn" id="cafeBtn" title="Cafés & Restaurants">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px;">
                <path d="M18 8h1a4 4 0 0 1 0 8h-1"></path>
                <path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path>
                <line x1="6" y1="1" x2="6" y2="4"></line>
                <line x1="10" y1="1" x2="10" y2="4"></line>
                <line x1="14" y1="1" x2="14" y2="4"></line>
            </svg>
            Cafés
        </button>
        <button class="poi-btn" id="shopBtn" title="Lebensmittelgeschäfte">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px;">
                <circle cx="9" cy="21" r="1"></circle>
                <circle cx="20" cy="21" r="1"></circle>
                <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
            </svg>
            Shops
        </button>
        <button class="poi-btn" id="bikeBtn" title="Fahrradläden & Reparatur">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px;">
                <circle cx="5.5" cy="17.5" r="3.5"></circle>
                <circle cx="18.5" cy="17.5" r="3.5"></circle>
                <path d="M15 6a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm-3 11.5V14l-3-3 4-3 2 3h2"></path>
            </svg>
            Bike
        </button>
    </div>
    
    <!-- X-Ray Magnifier Toggle Button -->
    <div class="magnifier-toggle" id="magnifierToggle" title="X-Ray Lupe aktivieren (L-Taste)">
        <div class="magnifier-toggle-icon">🔬</div>
    </div>
    
    <!-- Magnifier Settings Toggle -->
    <div class="magnifier-settings-toggle" id="magnifierSettingsToggle" title="Lupen-Einstellungen">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M12 1v6m0 6v6m-9-9h6m6 0h6"></path>
        </svg>
        Settings
    </div>
    
    <!-- Magnifier Settings Panel -->
    <div class="magnifier-settings" id="magnifierSettings">
        <h4>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="4"></circle>
                <line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line>
                <line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line>
                <line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line>
                <line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>
            </svg>
            X-RAY MAGNIFIER
        </h4>
        
        <!-- Size Control -->
        <div class="magnifier-setting-group">
            <div class="magnifier-setting-label">
                <span>📐 Größe</span>
                <span class="magnifier-setting-value" id="magSizeValue">250px</span>
            </div>
            <input type="range" id="magSizeSlider" class="magnifier-slider" min="150" max="400" value="250" step="10">
        </div>
        
        <!-- Zoom Control -->
        <div class="magnifier-setting-group">
            <div class="magnifier-setting-label">
                <span>🔭 Zoom Level</span>
                <span class="magnifier-setting-value" id="magZoomValue">+4</span>
            </div>
            <input type="range" id="magZoomSlider" class="magnifier-slider" min="2" max="8" value="4" step="1">
        </div>
        
        <!-- Mode Selection -->
        <div class="magnifier-setting-group">
            <div class="magnifier-setting-label">
                <span>🗺️ Modus</span>
            </div>
            <div class="magnifier-mode-select">
                <button class="magnifier-mode-btn" id="modeOSM" data-mode="osm">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    </svg>
                    OSM
                </button>
                <button class="magnifier-mode-btn active" id="modeSatellite" data-mode="satellite">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                        <circle cx="12" cy="12" r="10"></circle>
                    </svg>
                    Satellit
                </button>
                <button class="magnifier-mode-btn" id="modeTopo" data-mode="topo">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                        <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                    </svg>
                    Topo
                </button>
                <button class="magnifier-mode-btn" id="modeSurface" data-mode="surface">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                        <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                    </svg>
                    Surface
                </button>
            </div>
        </div>
        
        <!-- Features -->
        <div class="magnifier-setting-group">
            <div class="magnifier-setting-label">
                <span>⚙️ Features</span>
            </div>
            
            <div class="magnifier-feature-toggle active" id="featureRoute">
                <span class="magnifier-feature-label">🛣️ Route anzeigen</span>
                <div class="magnifier-toggle-switch"></div>
            </div>
            
            <div class="magnifier-feature-toggle active" id="featureSurface">
                <span class="magnifier-feature-label">🎨 Surface-Farben</span>
                <div class="magnifier-toggle-switch"></div>
            </div>
            
            <div class="magnifier-feature-toggle active" id="featurePOI">
                <span class="magnifier-feature-label">📍 POI Layer</span>
                <div class="magnifier-toggle-switch"></div>
            </div>
            
            <div class="magnifier-feature-toggle active" id="featureCoords">
                <span class="magnifier-feature-label">📊 Koordinaten</span>
                <div class="magnifier-toggle-switch"></div>
            </div>
            
            <div class="magnifier-feature-toggle" id="featureProfile">
                <span class="magnifier-feature-label">📈 Mini-Profil</span>
                <div class="magnifier-toggle-switch"></div>
            </div>
            
            <div class="magnifier-feature-toggle" id="featureMeasure">
                <span class="magnifier-feature-label">📏 Measure Tool</span>
                <div class="magnifier-toggle-switch"></div>
            </div>
            
            <div class="magnifier-feature-toggle active" id="featureSmartFocus">
                <span class="magnifier-feature-label">🎯 Smart Focus</span>
                <div class="magnifier-toggle-switch"></div>
            </div>
        </div>
        
        <!-- Actions -->
        <div class="magnifier-setting-group">
            <div class="magnifier-setting-label">
                <span>🎬 Aktionen</span>
            </div>
            <button class="magnifier-mode-btn" id="magSnapshot" style="width: 100%;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                    <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                    <circle cx="12" cy="13" r="4"></circle>
                </svg>
                Snapshot (S)
            </button>
        </div>
        
        <div style="font-size: 9px; color: #64748b; margin-top: 12px; text-align: center; line-height: 1.4;">
            💡 LEERTASTE = Freeze/Unfreeze<br>
            L = Toggle Magnifier<br>
            S = Screenshot
        </div>
    </div>
    
    <!-- Route Library Toggle -->
    <div class="library-toggle" id="libraryToggle" title="Route-Bibliothek">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px;">
            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
        </svg>
        Routen
    </div>
    
    <!-- Route Library Panel -->
    <div class="route-library" id="routeLibrary">
        <button class="route-library-close" id="libraryCloseBtn" title="Schließen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
        <h4>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px;">
                <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
            </svg>
            Meine Routen
        </h4>
        
        <div class="library-stats" id="libraryStats">
            <div class="library-stats-item">
                <span>Gespeicherte Routen:</span>
                <span class="library-stats-value" id="totalRoutes">0</span>
            </div>
            <div class="library-stats-item">
                <span>Gesamt-Distanz:</span>
                <span class="library-stats-value" id="totalDistance">0 km</span>
            </div>
        </div>
        
        <button class="heatmap-toggle" id="heatmapToggle">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px; display: inline-block; vertical-align: middle;">
                <path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
            </svg>
            Heatmap anzeigen
        </button>
        
        <div id="routeList" style="margin-top: 10px;"></div>
    </div>
    
    <!-- Elevation Tab Button -->
    <div class="elevation-tab" id="elevationToggle" title="Höhenprofil ein/ausblenden">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px;">
            <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
        </svg>
        Profil
    </div>
    
    <!-- Elevation Profile -->
    <div class="elevation-profile" id="elevationProfile">
        <!-- Header: Überschrift + Legende in einer Zeile -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
            <h4 style="margin: 0;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px; display: inline-block; vertical-align: middle;">
                    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                </svg>
                Höhenprofil
            </h4>
            
            <!-- Surface Legend (rechts neben Überschrift) -->
            <div id="surfaceLegend" style="display: none; font-size: 8px; color: #64748b; gap: 6px; align-items: center;">
                <span style="display: inline-flex; align-items: center; gap: 3px; white-space: nowrap;">
                    <span style="width: 10px; height: 10px; background: #10b981; border-radius: 2px; display: inline-block;"></span>
                    Asphalt
                </span>
                <span style="display: inline-flex; align-items: center; gap: 3px; white-space: nowrap;">
                    <span style="width: 10px; height: 10px; background: #eab308; border-radius: 2px; display: inline-block;"></span>
                    Compacted
                </span>
                <span style="display: inline-flex; align-items: center; gap: 3px; white-space: nowrap;">
                    <span style="width: 10px; height: 10px; background: #f97316; border-radius: 2px; display: inline-block;"></span>
                    Gravel
                </span>
                <span style="display: inline-flex; align-items: center; gap: 3px; white-space: nowrap;">
                    <span style="width: 10px; height: 10px; background: #ef4444; border-radius: 2px; display: inline-block;"></span>
                    Unpaved
                </span>
            </div>
        </div>
        
        <!-- Chart Toggle Buttons -->
        <div class="chart-toggles">
            <button class="chart-toggle-btn active" id="toggleElevationChart" title="Höhenprofil anzeigen/ausblenden">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px;">
                    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                </svg>
                Höhe
            </button>
            <button class="chart-toggle-btn" id="toggleSurfaceChart" title="Oberflächenprofil anzeigen/ausblenden">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px;">
                    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                    <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                    <line x1="12" y1="22.08" x2="12" y2="12"></line>
                </svg>
                Surface
            </button>
        </div>
        
        <canvas id="elevationChart"></canvas>
    </div>
    
    <div class="control-panel">
        <div class="profile-selector">
            <button class="profile-btn active" id="gravelBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px; display: inline-block; vertical-align: middle;">
                    <circle cx="12" cy="5" r="3"></circle>
                    <path d="M12 22V8M5 12H2l10-5 10 5h-3"></path>
                </svg>
                Gravel
            </button>
            <button class="profile-btn" id="roadBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 14px; height: 14px; display: inline-block; vertical-align: middle;">
                    <circle cx="12" cy="5" r="3"></circle>
                    <path d="M12 22V8M5 12H2l10-5 10 5h-3"></path>
                </svg>
                Rennrad
            </button>
        </div>
        <div class="elevation-preference">
            <button class="elevation-pref-btn active" id="flatElevBtn" title="Flachste Route (min. Höhenmeter)">
                <span class="pref-icon">🏞️</span>
                <span class="pref-label">Flach</span>
            </button>
            <button class="elevation-pref-btn" id="hillyElevBtn" title="Bergigste Route (max. Höhenmeter)">
                <span class="pref-icon">🏔️</span>
                <span class="pref-label">Bergig</span>
            </button>
        </div>
        <div class="speed-control">
            <label>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px; display: inline-block; vertical-align: middle;">
                    <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                </svg>
                Speed:
            </label>
            <input type="range" id="speedSlider" class="speed-slider" min="15" max="40" value="25" step="1">
            <div class="speed-value" id="speedValue">25 km/h</div>
        </div>
        <div class="waypoint-list"><div id="waypointList"></div></div>
        <button class="btn btn-primary" id="calculateBtn" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
            </svg>
            Berechnen
        </button>
        
        <button class="btn btn-secondary" id="reverseBtn" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="17 1 21 5 17 9"></polyline>
                <path d="M3 11V9a4 4 0 0 1 4-4h14"></path>
                <polyline points="7 23 3 19 7 15"></polyline>
                <path d="M21 13v2a4 4 0 0 1-4 4H3"></path>
            </svg>
            Umkehren
        </button>
        
        <button class="btn btn-danger" id="clearBtn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
            Löschen
        </button>
        
        <button class="btn btn-success" id="exportBtn" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                <polyline points="7 3 7 8 15 8"></polyline>
            </svg>
            GPX
        </button>
        
        <button class="btn" id="saveBtn" disabled style="background: linear-gradient(145deg, #8b5cf6, #7c3aed); color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                <polyline points="7 3 7 8 15 8"></polyline>
            </svg>
            Speichern
        </button>
        
        <!-- Engine Selector -->
        <div class="engine-selector" id="engineSelector">
            <div class="engine-label">🔧 Routing Engine:</div>
            <div class="engine-buttons">
                <button class="engine-btn active" data-engine="auto" title="Automatisch beste Engine wählen (BRouter → GraphHopper → Valhalla → OSRM)">
                    🔄 Auto
                </button>
                <button class="engine-btn" data-engine="brouter" title="BRouter (kostenlos, Gravel-optimiert)">
                    🚴 BRouter
                </button>
                <button class="engine-btn" data-engine="graphhopper" title="GraphHopper (API Key erforderlich)">
                    🗺️ GH
                </button>
                <button class="engine-btn" data-engine="valhalla" title="Valhalla (API Key erforderlich)">
                    ⛰️ Val
                </button>
                <button class="engine-btn" data-engine="osrm" title="OSRM (kostenlos)">
                    🌍 OSRM
                </button>
                <button class="engine-btn" data-engine="direct" title="Direkte Linie (für Offroad/Trampelpfade)">
                    📏 Direct
                </button>
            </div>
            <div class="engine-status" id="engineStatus">
                Status: Auto (BRouter → GraphHopper → Valhalla → OSRM)
            </div>
        </div>
        
        <span class="loading" id="loading">⏳ Berechne...</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <script>
        // ==========================================
        // PIXELRUUD CONFIGURATION
        // ==========================================
        
        const PIXELRUUD_CONFIG = {
            VERSION: '1.0.0',
            APP_NAME: 'Pixelruud',
            TAGLINE: 'Every pixel of your ride',
            SUBLINE: 'Your gravel companion',
            PREMIUM_ENABLED: false, // Set to true when ready to launch premium
        };
        
        // ==========================================
        // SUPABASE CONFIGURATION
        // ==========================================
        
        const SUPABASE_URL = 'https://fwiakuwsyttnnrgexalb.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ3aWFrdXdzeXR0bm5yZ2V4YWxiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU1MzY0NzQsImV4cCI6MjA4MTExMjQ3NH0.8vbfsHld3aS48LSgorAFM1hNgF-YBUfKpbZeTchT3Dg';
        
        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Current user state
        let currentUser = null;
        let userSubscription = null;
        
        // ==========================================
        // FEATURE FLAGS
        // ==========================================
        
        const FEATURES = {
            // Core Features (Always Free)
            basic_routing: { enabled: true, premium: false },
            magnifier: { enabled: true, premium: false },
            elevation: { enabled: true, premium: false },
            surface_analysis: { enabled: true, premium: false },
            poi_basic: { enabled: true, premium: false },
            gpx_export: { enabled: true, premium: false },
            
            // Premium Features (Ready, but disabled)
            unlimited_routes: { enabled: false, premium: true },
            cloud_sync: { enabled: true, premium: false }, // Free for now
            advanced_gpx: { enabled: false, premium: true },
            weather: { enabled: false, premium: true },
            offline_maps: { enabled: false, premium: true },
            premium_pois: { enabled: false, premium: true },
            
            // Team Features (Future)
            team_sharing: { enabled: false, team: true },
            live_tracking: { enabled: false, team: true }
        };
        
        // ==========================================
        // ANALYTICS (Plausible.io)
        // ==========================================
        
        function trackEvent(eventName, props = {}) {
            if (window.plausible) {
                window.plausible(eventName, { props });
            }
        }
        
        // ==========================================
        // USER AUTHENTICATION
        // ==========================================
        
        async function checkAuthState() {
            const { data: { session } } = await supabase.auth.getSession();
            if (session) {
                currentUser = session.user;
                await loadUserData();
                updateUIForAuthState(true);
            } else {
                updateUIForAuthState(false);
            }
        }
        
        async function loadUserData() {
            if (!currentUser) return;
            
            // Load user preferences
            const { data: prefs } = await supabase
                .from('user_preferences')
                .select('*')
                .eq('user_id', currentUser.id)
                .single();
            
            if (prefs) {
                applyUserPreferences(prefs);
            }
            
            // Load subscription status (for premium later)
            if (PIXELRUUD_CONFIG.PREMIUM_ENABLED) {
                const { data: sub } = await supabase
                    .from('subscriptions')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .single();
                
                userSubscription = sub;
            }
        }
        
        function applyUserPreferences(prefs) {
            // Apply saved preferences to UI
            if (prefs.routing_engine) currentEngine = prefs.routing_engine;
            if (prefs.default_profile) currentProfile = prefs.default_profile;
            if (prefs.elevation_preference) currentElevationPref = prefs.elevation_preference;
            // ... more preferences
        }
        
        function updateUIForAuthState(isLoggedIn) {
            // Update UI based on login state
            const loginBtn = document.getElementById('loginBtn');
            const userInfo = document.getElementById('userInfo');
            
            if (isLoggedIn && currentUser) {
                if (loginBtn) loginBtn.textContent = 'Account';
                if (userInfo) userInfo.textContent = currentUser.email;
            } else {
                if (loginBtn) loginBtn.textContent = 'Login';
                if (userInfo) userInfo.textContent = '';
            }
        }
        
        // ==========================================
        // CLOUD ROUTE STORAGE
        // ==========================================
        
        async function saveRouteToCloud(routeData) {
            if (!currentUser) {
                console.log('User not logged in, saving locally only');
                return saveRouteLocally(routeData);
            }
            
            trackEvent('Route Saved', { storage: 'cloud' });
            
            const { data, error } = await supabase
                .from('user_routes')
                .insert({
                    user_id: currentUser.id,
                    name: routeData.name || 'Unnamed Route',
                    description: routeData.description || '',
                    distance_km: routeData.distance,
                    elevation_gain_m: routeData.elevationGain,
                    surface_type: routeData.surfaceType || 'mixed',
                    gravel_percentage: routeData.gravelPercentage || 0,
                    difficulty: routeData.difficulty || 'moderate',
                    route_data: routeData,
                    usage_count: 1
                })
                .select()
                .single();
            
            if (error) {
                console.error('Error saving to cloud:', error);
                return saveRouteLocally(routeData);
            }
            
            return data;
        }
        
        async function loadRoutesFromCloud() {
            if (!currentUser) return [];
            
            const { data, error } = await supabase
                .from('user_routes')
                .select('*')
                .eq('user_id', currentUser.id)
                .order('created_at', { ascending: false });
            
            if (error) {
                console.error('Error loading routes:', error);
                return [];
            }
            
            return data;
        }
        
        function saveRouteLocally(routeData) {
            // Fallback to localStorage
            const routes = JSON.parse(localStorage.getItem('pixelruud_routes') || '[]');
            routes.unshift(routeData);
            
            // Limit to 10 routes for free users
            if (routes.length > 10 && !checkPremiumStatus()) {
                routes.pop();
            }
            
            localStorage.setItem('pixelruud_routes', JSON.stringify(routes));
            return routeData;
        }
        
        function checkPremiumStatus() {
            if (!PIXELRUUD_CONFIG.PREMIUM_ENABLED) return false;
            return userSubscription && userSubscription.status === 'active';
        }
        
        // Initialize auth on load
        checkAuthState();
        
        // Listen for auth changes
        supabase.auth.onAuthStateChange((event, session) => {
            if (event === 'SIGNED_IN') {
                currentUser = session.user;
                loadUserData();
                updateUIForAuthState(true);
            } else if (event === 'SIGNED_OUT') {
                currentUser = null;
                userSubscription = null;
                updateUIForAuthState(false);
            }
        });
        
        // ==========================================
        // ORIGINAL APP CODE STARTS HERE
        // ==========================================
        
        let map, waypoints = [], markers = [], routes = [], routeLines = [];
        let currentProfile = 'gravel', averageSpeed = 25;
        let currentEngine = 'auto'; // 'auto', 'brouter', 'graphhopper', 'valhalla', 'osrm', 'direct'
        let directLineMode = false; // Für Trampelpfade
        let currentElevationPref = 'flat'; // 'flat' or 'hilly'
        let apiKeys = {
            graphhopper: localStorage.getItem('graphhopper_api_key') || '',
            valhalla: localStorage.getItem('valhalla_api_key') || ''
        };
        let poiLayers = {
            water: null,
            cafe: null,
            shop: null,
            bike: null
        };
        let elevationChart = null;
        let surfaceChart = null;
        let heatmapLayer = null;
        let savedRoutes = [];

        (function init() {
            if (typeof L === 'undefined') { setTimeout(init, 50); return; }
            
            document.getElementById('loadingMessage').style.display = 'none';
            map = L.map('map').setView([48.1351, 11.5820], 12);
            
            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap',
                maxZoom: 19
            }).addTo(map);
            
            const cycleLayer = L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
                attribution: '© CyclOSM | © OpenStreetMap',
                maxZoom: 20
            });
            
            const topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenTopoMap',
                maxZoom: 17
            });
            
            const hikeBikeLayer = L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors, CyclOSM',
                maxZoom: 20,
                subdomains: 'abc'
            });
            
            const sateliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '© Esri',
                maxZoom: 19
            });
            
            const outdoorsLayer = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors, Tiles courtesy of HOT',
                maxZoom: 19
            });
            
            const cartoCDNLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap © CARTO',
                maxZoom: 19
            });
            
            const baseMaps = {
                "🗺️ Standard": osmLayer,
                "🚴 Radkarte": cycleLayer,
                "⛰️ Topografisch": topoLayer,
                "🚲 CyclOSM": hikeBikeLayer,
                "🌍 Humanitarian": outdoorsLayer,
                "🌐 Light": cartoCDNLayer,
                "🛰️ Satellit": sateliteLayer
            };
            
            L.control.layers(baseMaps).addTo(map);
            
            map.on('click', e => addWaypoint(e.latlng.lat, e.latlng.lng));
            
            document.getElementById('calculateBtn').onclick = calculateRoutes;
            document.getElementById('reverseBtn').onclick = reverseRoute;
            document.getElementById('clearBtn').onclick = clearAll;
            document.getElementById('exportBtn').onclick = exportGPX;
            document.getElementById('saveBtn').onclick = promptSaveRoute;
            document.getElementById('gravelBtn').onclick = () => setProfile('gravel');
            document.getElementById('roadBtn').onclick = () => setProfile('road');
            document.getElementById('speedSlider').oninput = e => updateSpeed(e.target.value);
            
            // Elevation Preference Buttons (2 options)
            document.getElementById('flatElevBtn').onclick = () => setElevationPreference('flat');
            document.getElementById('hillyElevBtn').onclick = () => setElevationPreference('hilly');
            
            // API Settings
            setupAPISettings();
            
            // GPX Import
            setupGPXImport();
            
            // Setup POI functionality - THIS WAS MISSING!
            setupPOI();
            
            // Setup Address Search
            setupAddressSearch();
            
            // Setup Magnifier
            setupMagnifier();
            
            // Setup Route Library
            setupRouteLibrary();
            
            // Setup Panel Toggles
            setupPanelToggles();
            
            // Setup Chart Toggles (Elevation/Surface)
            setupChartToggles();
            
            // Setup Engine Selector
            setupEngineSelector();
            
            // Load saved routes from localStorage
            loadSavedRoutes();
            
            // Setup proximity fading for panels
            setupProximityFading();
            
            console.log('✓ App initialisiert (inkl. POI + Adresssuche + Lupe + Route-Bibliothek)');
        })();
        
        function setupPOI() {
            const waterBtn = document.getElementById('waterBtn');
            const cafeBtn = document.getElementById('cafeBtn');
            const shopBtn = document.getElementById('shopBtn');
            const bikeBtn = document.getElementById('bikeBtn');
            
            waterBtn.addEventListener('click', () => togglePOI('water', waterBtn));
            cafeBtn.addEventListener('click', () => togglePOI('cafe', cafeBtn));
            shopBtn.addEventListener('click', () => togglePOI('shop', shopBtn));
            bikeBtn.addEventListener('click', () => togglePOI('bike', bikeBtn));
            
            console.log('✓ POI buttons initialized');
        }
        
        function setupAddressSearch() {
            const addressInput = document.getElementById('addressInput');
            const addressResults = document.getElementById('addressResults');
            let searchTimeout;
            
            addressInput.addEventListener('input', function(e) {
                const query = e.target.value.trim();
                
                clearTimeout(searchTimeout);
                
                if (query.length < 3) {
                    addressResults.classList.remove('show');
                    addressResults.innerHTML = '';
                    return;
                }
                
                searchTimeout = setTimeout(() => {
                    searchAddress(query);
                }, 500);
            });
            
            addressInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    const query = e.target.value.trim();
                    if (query.length >= 3) {
                        searchAddress(query);
                    }
                }
            });
            
            console.log('✓ Address search initialized');
        }
        
        async function searchAddress(query) {
            const addressResults = document.getElementById('addressResults');
            
            try {
                addressResults.innerHTML = '<div style="padding: 8px; font-size: 11px; color: #64748b;">Suche...</div>';
                addressResults.classList.add('show');
                
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`, {
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                const results = await response.json();
                
                if (results.length === 0) {
                    addressResults.innerHTML = '<div style="padding: 8px; font-size: 11px; color: #64748b;">Keine Ergebnisse gefunden</div>';
                    return;
                }
                
                addressResults.innerHTML = results.map(result => {
                    const displayName = result.display_name.length > 60 
                        ? result.display_name.substring(0, 60) + '...' 
                        : result.display_name;
                    
                    return `<div class="address-result-item" 
                                 onclick="selectAddress(${result.lat}, ${result.lon}, '${result.display_name.replace(/'/g, "\\'")}')">
                        📍 ${displayName}
                    </div>`;
                }).join('');
                
                console.log(`✓ Found ${results.length} address results`);
                
            } catch (error) {
                console.error('Address search error:', error);
                addressResults.innerHTML = '<div style="padding: 8px; font-size: 11px; color: #ef4444;">Fehler bei der Suche</div>';
            }
        }
        
        function selectAddress(lat, lng, displayName) {
            const addressResults = document.getElementById('addressResults');
            const addressInput = document.getElementById('addressInput');
            
            // Add waypoint at selected address
            addWaypoint(parseFloat(lat), parseFloat(lng));
            
            // Center map on location
            map.setView([lat, lng], 15, { animate: true });
            
            // Clear search
            addressInput.value = '';
            addressResults.classList.remove('show');
            addressResults.innerHTML = '';
            
            console.log(`✓ Selected address: ${displayName}`);
        }
        
        
        // ========================================
        // GPX IMPORT
        // ========================================
        
        function setupGPXImport() {
            const importBtn = document.getElementById('gpxImportToggle');
            const fileInput = document.getElementById('gpxImportInput');
            
            // Click button opens file dialog
            importBtn.addEventListener('click', () => {
                fileInput.click();
            });
            
            // Handle file selection
            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    await parseAndLoadGPX(text, file.name);
                    
                    // Reset input so same file can be loaded again
                    fileInput.value = '';
                } catch (error) {
                    console.error('GPX Import Error:', error);
                    alert('Fehler beim Laden der GPX-Datei: ' + error.message);
                }
            });
            
            console.log('✓ GPX Import initialized');
        }
        
        async function parseAndLoadGPX(gpxText, filename) {
            // Parse GPX XML
            const parser = new DOMParser();
            const gpxDoc = parser.parseFromString(gpxText, 'text/xml');
            
            // Check for parsing errors
            if (gpxDoc.querySelector('parsererror')) {
                throw new Error('Ungültiges GPX-Format');
            }
            
            // Extract track points (trkpt) or route points (rtept)
            let points = Array.from(gpxDoc.querySelectorAll('trkpt'));
            if (points.length === 0) {
                points = Array.from(gpxDoc.querySelectorAll('rtept'));
            }
            
            if (points.length === 0) {
                throw new Error('Keine Trackpoints in GPX gefunden');
            }
            
            console.log(`📂 GPX loaded: ${filename} - ${points.length} points`);
            
            // Extract coordinates and elevations
            const coordinates = [];
            const geometry = [];
            const elevations = [];
            
            points.forEach(pt => {
                const lat = parseFloat(pt.getAttribute('lat'));
                const lon = parseFloat(pt.getAttribute('lon'));
                const ele = pt.querySelector('ele');
                const elevation = ele ? parseFloat(ele.textContent) : 0;
                
                coordinates.push([lat, lon]);
                geometry.push([lon, lat]);
                elevations.push(elevation);
            });
            
            // Check if we got any elevation data from GPX
            const hasElevation = elevations.some(e => e !== 0);
            
            if (!hasElevation) {
                console.log('⚠️ GPX has no elevation data, fetching from API...');
                try {
                    // Fetch elevation for all points (sample every 10th point to avoid API limits)
                    const sampleStep = Math.max(1, Math.floor(coordinates.length / 100));
                    const sampledCoords = [];
                    const sampledIndices = [];
                    
                    for (let i = 0; i < coordinates.length; i += sampleStep) {
                        sampledCoords.push(coordinates[i]);
                        sampledIndices.push(i);
                    }
                    
                    // Fetch elevations in batches
                    const locations = sampledCoords.map(c => ({ latitude: c[0], longitude: c[1] }));
                    const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ locations })
                    });
                    
                    const data = await response.json();
                    
                    // Interpolate elevations for all points
                    data.results.forEach((result, idx) => {
                        const realIdx = sampledIndices[idx];
                        elevations[realIdx] = result.elevation;
                    });
                    
                    // Linear interpolation for points between samples
                    for (let i = 0; i < elevations.length; i++) {
                        if (elevations[i] === 0) {
                            // Find previous and next known elevation
                            let prevIdx = i - 1;
                            while (prevIdx >= 0 && elevations[prevIdx] === 0) prevIdx--;
                            let nextIdx = i + 1;
                            while (nextIdx < elevations.length && elevations[nextIdx] === 0) nextIdx++;
                            
                            if (prevIdx >= 0 && nextIdx < elevations.length) {
                                const ratio = (i - prevIdx) / (nextIdx - prevIdx);
                                elevations[i] = elevations[prevIdx] + ratio * (elevations[nextIdx] - elevations[prevIdx]);
                            }
                        }
                    }
                    
                    console.log(`✓ Fetched elevation data from API (${sampledCoords.length} points sampled)`);
                } catch (error) {
                    console.error('Failed to fetch elevation data:', error);
                }
            }
            
            // Calculate total distance
            let totalDistance = 0;
            for (let i = 1; i < coordinates.length; i++) {
                const prev = coordinates[i - 1];
                const curr = coordinates[i];
                
                const R = 6371;
                const lat1 = prev[0] * Math.PI / 180;
                const lat2 = curr[0] * Math.PI / 180;
                const dLat = (curr[0] - prev[0]) * Math.PI / 180;
                const dLon = (curr[1] - prev[1]) * Math.PI / 180;
                
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1) * Math.cos(lat2) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                totalDistance += R * c;
            }
            
            // Clear existing routes
            clearRoutes();
            
            // Create route object
            const stats = calculateElevationStats(elevations);
            routes = [{
                distance: totalDistance,
                coordinates: coordinates,
                geometry: geometry,
                elevations: elevations,
                stats: stats
            }];
            
            // Draw route on map
            function drawGPXRouteOnMap(withSurfaceColors = false) {
                // Remove old route lines
                routeLines.forEach(line => map.removeLayer(line));
                routeLines = [];
                
                if (!withSurfaceColors || !window.surfaceData || window.surfaceData.length === 0) {
                    // Draw single blue line
                    const routeLine = L.polyline(coordinates, {
                        color: '#3b82f6',
                        weight: 4,
                        opacity: 0.8
                    }).addTo(map);
                    routeLines.push(routeLine);
                    return;
                }
                
                // Draw multi-colored line segments
                const surfaceColors = {
                    'paved': '#10b981',
                    'asphalt': '#10b981',
                    'compacted': '#eab308',
                    'gravel': '#f97316',
                    'unpaved': '#ef4444',
                    'dirt': '#dc2626',
                    'ground': '#b91c1c',
                    'sand': '#f59e0b',
                    'unknown': '#94a3b8'
                };
                
                const pointsPerSegment = Math.ceil(coordinates.length / window.surfaceData.length);
                
                for (let i = 0; i < window.surfaceData.length; i++) {
                    const startIdx = i * pointsPerSegment;
                    const endIdx = Math.min((i + 1) * pointsPerSegment + 1, coordinates.length);
                    const segmentCoords = coordinates.slice(startIdx, endIdx);
                    
                    if (segmentCoords.length < 2) continue;
                    
                    const surface = window.surfaceData[i];
                    const color = surfaceColors[surface] || surfaceColors['unknown'];
                    
                    const segmentLine = L.polyline(segmentCoords, {
                        color: color,
                        weight: 4,
                        opacity: 0.8
                    }).addTo(map);
                    
                    routeLines.push(segmentLine);
                }
            }
            
            // Draw initial blue route
            drawGPXRouteOnMap(false);
            
            // Store redraw function globally
            window.redrawMapRoute = drawGPXRouteOnMap;
            
            // Fit map to route
            if (routeLines.length > 0) {
                map.fitBounds(routeLines[0].getBounds(), { padding: [50, 50] });
            }
            
            // Extract waypoints - one waypoint per kilometer
            const waypointIndices = [];
            
            // Always include start
            waypointIndices.push(0);
            
            // Calculate cumulative distances to find waypoints at ~1km intervals
            let cumulativeDistance = 0;
            let nextWaypointDistance = 1; // Next waypoint at 1km
            
            for (let i = 1; i < coordinates.length; i++) {
                const prev = coordinates[i - 1];
                const curr = coordinates[i];
                
                // Haversine distance
                const R = 6371;
                const lat1 = prev[0] * Math.PI / 180;
                const lat2 = curr[0] * Math.PI / 180;
                const dLat = (curr[0] - prev[0]) * Math.PI / 180;
                const dLon = (curr[1] - prev[1]) * Math.PI / 180;
                
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1) * Math.cos(lat2) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const dist = R * c;
                
                cumulativeDistance += dist;
                
                // Add waypoint if we've reached the next km mark
                if (cumulativeDistance >= nextWaypointDistance) {
                    waypointIndices.push(i);
                    nextWaypointDistance += 1; // Next waypoint in 1km
                }
            }
            
            // Always include end
            if (waypointIndices[waypointIndices.length - 1] !== coordinates.length - 1) {
                waypointIndices.push(coordinates.length - 1);
            }
            
            console.log(`📍 Created ${waypointIndices.length} waypoints (~1 per km) for ${totalDistance.toFixed(2)} km route`);
            
            waypoints = [];
            markers = [];
            
            waypointIndices.forEach((idx, wpIdx) => {
                const coord = coordinates[idx];
                const wp = { lat: coord[0], lng: coord[1] };
                waypoints.push(wp);
                
                // Color coding: green = start, red = end, blue = intermediate
                const isStart = wpIdx === 0;
                const isEnd = wpIdx === waypointIndices.length - 1;
                const color = isStart ? '#10b981' : isEnd ? '#ef4444' : '#3b82f6';
                
                const markerIcon = L.divIcon({
                    className: 'waypoint-marker',
                    html: `<div style="background: ${color}; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 11px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${wpIdx + 1}</div>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                
                const marker = L.marker([wp.lat, wp.lng], { 
                    icon: markerIcon,
                    draggable: true
                }).addTo(map);
                
                marker.on('dragend', function(e) {
                    waypoints[wpIdx] = e.target.getLatLng();
                    // Enable recalculation after dragging
                    document.getElementById('calculateBtn').disabled = false;
                });
                
                markers.push(marker);
            });
            
            // Update UI
            document.getElementById('waypointList').innerHTML = waypoints.map((wp, i) => 
                `<div style="padding: 3px 0; font-size: 11px; color: #64748b;">
                    ${i === 0 ? '🟢' : i === waypoints.length - 1 ? '🔴' : '🔵'} Punkt ${i + 1}
                </div>`
            ).join('');
            
            // Enable calculate button
            const calculateBtn = document.getElementById('calculateBtn');
            calculateBtn.disabled = false;
            
            // Update stats panel
            const time = totalDistance / averageSpeed;
            document.getElementById('statsContent').innerHTML = `
                <div class="stats-highlight">
                    <div class="stat-item"><span class="stat-label">📏 Distanz:</span><span class="stat-value">${totalDistance.toFixed(2)} km</span></div>
                    <div class="stat-item"><span class="stat-label">⏱️ Zeit:</span><span class="stat-value">${Math.floor(time)}:${Math.round((time%1)*60).toString().padStart(2,'0')} h</span></div>
                    <div class="stat-item"><span class="stat-label">🚴 Speed:</span><span class="stat-value">${averageSpeed} km/h</span></div>
                </div>
                <div class="stat-item"><span class="stat-label">📊 Höhenmeter:</span><span class="stat-value">${stats.elevationGain} m</span></div>
                <div class="stat-item"><span class="stat-label">⛰️ Anstieg:</span><span class="stat-value">${stats.elevationGain} m</span></div>
                <div class="stat-item"><span class="stat-label">⛷️ Abstieg:</span><span class="stat-value">${stats.elevationLoss} m</span></div>
                <div class="stat-item"><span class="stat-label">🏔️ Max:</span><span class="stat-value">${stats.maxElevation} m</span></div>
                <div class="stat-item"><span class="stat-label">🏞️ Min:</span><span class="stat-value">${stats.minElevation} m</span></div>
            `;
            
            showElevationProfile();
            analyzeSurface(geometry);
            
            // Show toggle buttons
            document.getElementById('statsToggle').classList.add('show');
            document.getElementById('elevationToggle').classList.add('show');
            
            console.log(`✓ GPX Route geladen: ${totalDistance.toFixed(2)} km, ${points.length} Punkte → ${waypoints.length} Waypoints`);
            alert(`✓ GPX Route geladen!\n\n${filename}\n${totalDistance.toFixed(2)} km, ${Math.round(stats.elevationGain)} Höhenmeter\n\n→ Du kannst jetzt die ${waypoints.length} Wegpunkte verschieben und neu berechnen.`);
        }
        
        // ========================================
        // API SETTINGS
        // ========================================
        
        function setupAPISettings() {
            const toggle = document.getElementById('apiSettingsToggle');
            const panel = document.getElementById('apiSettingsPanel');
            const saveBtn = document.getElementById('apiSaveBtn');
            const ghInput = document.getElementById('graphhopperKeyInput');
            const valInput = document.getElementById('valhallaKeyInput');
            
            // Load saved keys
            ghInput.value = apiKeys.graphhopper;
            valInput.value = apiKeys.valhalla;
            
            // Toggle panel
            toggle.addEventListener('click', () => {
                panel.classList.toggle('show');
            });
            
            // Save keys
            saveBtn.addEventListener('click', () => {
                apiKeys.graphhopper = ghInput.value.trim();
                apiKeys.valhalla = valInput.value.trim();
                
                localStorage.setItem('graphhopper_api_key', apiKeys.graphhopper);
                localStorage.setItem('valhalla_api_key', apiKeys.valhalla);
                
                panel.classList.remove('show');
                
                console.log('✓ API Keys gespeichert');
                alert('API Keys gespeichert!\n\n' + 
                      'GraphHopper: ' + (apiKeys.graphhopper ? '✓ Aktiviert' : '✗ Nicht gesetzt') + '\n' +
                      'Valhalla: ' + (apiKeys.valhalla ? '✓ Aktiviert' : '✗ Nicht gesetzt') + '\n\n' +
                      'Routing-Reihenfolge:\n1. BRouter\n' +
                      (apiKeys.graphhopper ? '2. GraphHopper\n' : '') +
                      (apiKeys.valhalla ? (apiKeys.graphhopper ? '3' : '2') + '. Valhalla\n' : '') +
                      (apiKeys.graphhopper && apiKeys.valhalla ? '4' : apiKeys.graphhopper || apiKeys.valhalla ? '3' : '2') + '. OSRM (Fallback)');
            });
            
            console.log('✓ API Settings initialized');
        }
        
        // ========================================
        // PANEL TOGGLES
        // ========================================
        
        function setupPanelToggles() {
            const statsToggle = document.getElementById('statsToggle');
            const statsPanel = document.getElementById('statsPanel');
            const elevationToggle = document.getElementById('elevationToggle');
            const elevationProfile = document.getElementById('elevationProfile');
            
            // Stats Toggle
            statsToggle.addEventListener('click', () => {
                const isShown = statsPanel.classList.contains('show');
                if (isShown) {
                    statsPanel.classList.remove('show');
                    statsToggle.classList.remove('active');
                } else {
                    statsPanel.classList.add('show');
                    statsToggle.classList.add('active');
                }
            });
            
            // Elevation Toggle
            elevationToggle.addEventListener('click', () => {
                const isShown = elevationProfile.classList.contains('show');
                if (isShown) {
                    elevationProfile.classList.remove('show');
                    elevationToggle.classList.remove('active');
                } else {
                    elevationProfile.classList.add('show');
                    elevationToggle.classList.add('active');
                }
            });
            
            // Auto-transparency for Stats Panel
            statsPanel.addEventListener('mouseenter', () => {
                statsPanel.classList.remove('faded');
            });
            
            statsPanel.addEventListener('mouseleave', () => {
                if (statsPanel.classList.contains('show')) {
                    statsPanel.classList.add('faded');
                }
            });
            
            // Auto-transparency for Elevation Profile
            elevationProfile.addEventListener('mouseenter', () => {
                elevationProfile.classList.remove('faded');
            });
            
            elevationProfile.addEventListener('mouseleave', () => {
                if (elevationProfile.classList.contains('show')) {
                    elevationProfile.classList.add('faded');
                }
            });
            
            console.log('✓ Panel toggles initialized');
        }
        
        function setupChartToggles() {
            try {
                const toggleElevationBtn = document.getElementById('toggleElevationChart');
                const toggleSurfaceBtn = document.getElementById('toggleSurfaceChart');
                const elevationChartCanvas = document.getElementById('elevationChart');
                
                if (!toggleElevationBtn || !toggleSurfaceBtn) {
                    console.error('Chart toggle buttons not found');
                    return;
                }
                
                // Toggle Elevation Chart
                toggleElevationBtn.addEventListener('click', () => {
                    const isActive = toggleElevationBtn.classList.contains('active');
                    
                    if (isActive) {
                        toggleElevationBtn.classList.remove('active');
                        elevationChartCanvas.style.display = 'none';
                    } else {
                        toggleElevationBtn.classList.add('active');
                        elevationChartCanvas.style.display = 'block';
                    }
                    
                    console.log(`Elevation chart ${isActive ? 'hidden' : 'shown'}`);
                });
                
                // Toggle Surface Chart
                toggleSurfaceBtn.addEventListener('click', () => {
                    const isActive = toggleSurfaceBtn.classList.contains('active');
                    const legend = document.getElementById('surfaceLegend');
                    
                    if (isActive) {
                        toggleSurfaceBtn.classList.remove('active');
                        if (legend) legend.style.display = 'none';
                        
                        // Redraw map route in blue
                        if (typeof window.redrawMapRoute === 'function') {
                            window.redrawMapRoute(false);
                        }
                    } else {
                        toggleSurfaceBtn.classList.add('active');
                        if (legend) legend.style.display = 'flex';
                        
                        // Redraw map route in surface colors
                        if (typeof window.redrawMapRoute === 'function') {
                            window.redrawMapRoute(true);
                        }
                    }
                    
                    // Redraw elevation chart to show/hide surface line via plugin
                    if (elevationChart) {
                        elevationChart.update();
                    }
                    
                    console.log(`Surface ${isActive ? 'hidden' : 'shown'} (chart + map)`);
                });
                
                console.log('✓ Chart toggles initialized');
            } catch (error) {
                console.error('Error in setupChartToggles:', error);
            }
        }
        
        // ==========================================
        // ENGINE SELECTOR & PER-SEGMENT OVERRIDE
        // ==========================================
        
        let segmentOverrides = {};  // { "0-1": "direct", "2-3": "brouter", ... }
        
        function setupEngineSelector() {
            const engineButtons = document.querySelectorAll('.engine-btn');
            
            engineButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active from all
                    engineButtons.forEach(b => b.classList.remove('active'));
                    
                    // Set active
                    this.classList.add('active');
                    
                    // Update current engine
                    currentEngine = this.dataset.engine;
                    
                    // Update status
                    updateEngineStatus();
                    
                    // Recalculate if route exists
                    if (routes.length > 0) {
                        console.log(`🔄 Engine switched to: ${currentEngine} - Recalculating route...`);
                        calculateRoutes();
                    } else {
                        console.log(`Engine set to: ${currentEngine}`);
                    }
                    
                    trackEvent('Engine Changed', { engine: currentEngine });
                });
            });
            
            updateEngineStatus();
            console.log('✓ Engine selector initialized');
        }
        
        function updateEngineStatus() {
            const status = document.getElementById('engineStatus');
            if (!status) return;
            
            switch(currentEngine) {
                case 'auto':
                    status.textContent = 'Status: Auto (BRouter → GraphHopper → Valhalla → OSRM)';
                    status.className = 'engine-status';
                    break;
                case 'brouter':
                    status.textContent = 'Status: BRouter (Gravel-optimiert, kostenlos)';
                    status.className = 'engine-status using';
                    break;
                case 'graphhopper':
                    status.textContent = apiKeys.graphhopper ? 
                        'Status: GraphHopper (API Key aktiv)' : 
                        'Status: GraphHopper (⚠️ API Key fehlt!)';
                    status.className = 'engine-status using';
                    break;
                case 'valhalla':
                    status.textContent = apiKeys.valhalla ? 
                        'Status: Valhalla (API Key aktiv)' : 
                        'Status: Valhalla (⚠️ API Key fehlt!)';
                    status.className = 'engine-status using';
                    break;
                case 'osrm':
                    status.textContent = 'Status: OSRM (kostenlos)';
                    status.className = 'engine-status using';
                    break;
                case 'direct':
                    status.textContent = 'Status: Direct Mode (Luftlinie - für Offroad/Trampelpfade)';
                    status.className = 'engine-status direct';
                    break;
            }
        }
        
        // Direct Line Routing Function
        function getDirectRoute(start, end) {
            // Simple straight line between points
            const coords = [
                [start.lat, start.lng],
                [end.lat, end.lng]
            ];
            
            // Calculate distance (Haversine)
            const R = 6371; // Earth radius in km
            const dLat = (end.lat - start.lat) * Math.PI / 180;
            const dLon = (end.lng - start.lng) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(start.lat * Math.PI / 180) * Math.cos(end.lat * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const distance = R * c;
            
            return {
                coordinates: coords,
                geometry: coords.map(c => [c[1], c[0]]), // swap for Leaflet
                distance: distance,
                elevations: null // Will be fetched later
            };
        }
        
        // Show segment context menu on route line right-click
        function showSegmentMenu(segmentIndex, latlng) {
            // Remove existing menu if any
            if (window.currentSegmentMenu) {
                map.closePopup(window.currentSegmentMenu);
            }
            
            const currentOverride = segmentOverrides[segmentIndex] || 'auto';
            
            const menuHTML = `
                <div class="segment-menu">
                    <div class="segment-menu-title">Segment ${segmentIndex.replace('-', ' → ')}</div>
                    <button class="segment-menu-btn ${currentOverride === 'auto' ? 'active' : ''}" 
                            onclick="setSegmentEngine('${segmentIndex}', 'auto')">
                        🔄 Auto (Standard)
                    </button>
                    <button class="segment-menu-btn ${currentOverride === 'direct' ? 'active' : ''}" 
                            onclick="setSegmentEngine('${segmentIndex}', 'direct')">
                        📏 Direct (Luftlinie)
                    </button>
                    <button class="segment-menu-btn ${currentOverride === 'brouter' ? 'active' : ''}" 
                            onclick="setSegmentEngine('${segmentIndex}', 'brouter')">
                        🚴 BRouter only
                    </button>
                    <button class="segment-menu-btn ${currentOverride === 'osrm' ? 'active' : ''}" 
                            onclick="setSegmentEngine('${segmentIndex}', 'osrm')">
                        🌍 OSRM only
                    </button>
                    <button class="segment-menu-btn ${currentOverride === 'graphhopper' ? 'active' : ''}" 
                            onclick="setSegmentEngine('${segmentIndex}', 'graphhopper')" 
                            ${!apiKeys.graphhopper ? 'disabled title="API Key fehlt"' : ''}>
                        🗺️ GraphHopper only
                    </button>
                </div>
            `;
            
            const popup = L.popup({
                closeButton: true,
                autoClose: true,
                closeOnClick: false
            })
            .setLatLng(latlng)
            .setContent(menuHTML)
            .openOn(map);
            
            window.currentSegmentMenu = popup;
            
            console.log(`Segment menu opened for ${segmentIndex}`);
        }
        
        // Make this global so it can be called from popup HTML
        window.setSegmentEngine = function(segmentIndex, engine) {
            segmentOverrides[segmentIndex] = engine;
            console.log(`✓ Segment ${segmentIndex} engine set to: ${engine}`);
            
            // Close menu
            if (window.currentSegmentMenu) {
                map.closePopup(window.currentSegmentMenu);
            }
            
            // Recalculate route
            if (routes.length > 0) {
                console.log('🔄 Recalculating route with new segment engine...');
                calculateRoutes();
            }
            
            trackEvent('Segment Engine Override', { segment: segmentIndex, engine: engine });
        };
        
        function setupMagnifier() {
            const magnifier = document.getElementById('magnifier');
            const magnifierToggle = document.getElementById('magnifierToggle');
            const magnifierSettings = document.getElementById('magnifierSettings');
            const magnifierSettingsToggle = document.getElementById('magnifierSettingsToggle');
            
            // State
            let magnifierEnabled = false;
            let magnifierFrozen = false;
            let magnifierMap = null;
            let magnifierRouteLayer = null;
            let magnifierMarkersLayer = null;
            let magnifierPOILayer = null;
            let magnifierCanvas = null;
            let magnifierCtx = null;
            let currentMode = 'satellite';
            let currentSize = 250;
            let currentZoom = 4;
            let frozenPosition = null;
            
            // Features state
            const features = {
                route: true,
                surface: true,
                poi: true,
                coords: true,
                profile: false,
                measure: false,
                smartFocus: true
            };
            
            // Initialize canvas for WebGL surface overlay
            magnifierCanvas = document.getElementById('magnifierCanvas');
            magnifierCtx = magnifierCanvas.getContext('2d');
            
            // Toggle magnifier with button
            // ===== DRAG & DROP FUNCTIONALITY FOR MAGNIFIER BUTTONS =====
            
            // Make Magnifier Toggle draggable
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            let hasMoved = false;
            
            magnifierToggle.addEventListener('mousedown', function(e) {
                if (e.button !== 0) return; // Only left mouse button
                
                isDragging = true;
                hasMoved = false;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                
                const rect = magnifierToggle.getBoundingClientRect();
                dragOffsetX = e.clientX - rect.left;
                dragOffsetY = e.clientY - rect.top;
                
                magnifierToggle.classList.add('dragging');
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const moveX = Math.abs(e.clientX - dragStartX);
                const moveY = Math.abs(e.clientY - dragStartY);
                
                if (moveX > 5 || moveY > 5) {
                    hasMoved = true;
                }
                
                if (hasMoved) {
                    const x = e.clientX - dragOffsetX;
                    const y = e.clientY - dragOffsetY;
                    
                    // Keep within viewport bounds
                    const maxX = window.innerWidth - magnifierToggle.offsetWidth;
                    const maxY = window.innerHeight - magnifierToggle.offsetHeight;
                    
                    const boundedX = Math.max(0, Math.min(x, maxX));
                    const boundedY = Math.max(0, Math.min(y, maxY));
                    
                    magnifierToggle.style.left = boundedX + 'px';
                    magnifierToggle.style.bottom = 'auto';
                    magnifierToggle.style.top = boundedY + 'px';
                    
                    // Save position to localStorage
                    localStorage.setItem('magnifierTogglePos', JSON.stringify({x: boundedX, y: boundedY}));
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                if (!isDragging) return;
                
                isDragging = false;
                magnifierToggle.classList.remove('dragging');
                
                // If didn't move significantly, allow the click event to fire naturally
                // The click handler will check hasMoved to prevent double-trigger
                
                // Reset hasMoved after a short delay
                setTimeout(() => {
                    hasMoved = false;
                }, 100);
            });
            
            // Make Settings Toggle draggable
            let isSettingsDragging = false;
            let settingsDragStartX = 0;
            let settingsDragStartY = 0;
            let settingsDragOffsetX = 0;
            let settingsDragOffsetY = 0;
            let settingsHasMoved = false;
            
            magnifierSettingsToggle.addEventListener('mousedown', function(e) {
                if (e.button !== 0) return;
                
                isSettingsDragging = true;
                settingsHasMoved = false;
                settingsDragStartX = e.clientX;
                settingsDragStartY = e.clientY;
                
                const rect = magnifierSettingsToggle.getBoundingClientRect();
                settingsDragOffsetX = e.clientX - rect.left;
                settingsDragOffsetY = e.clientY - rect.top;
                
                magnifierSettingsToggle.classList.add('dragging');
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isSettingsDragging) return;
                
                const moveX = Math.abs(e.clientX - settingsDragStartX);
                const moveY = Math.abs(e.clientY - settingsDragStartY);
                
                if (moveX > 5 || moveY > 5) {
                    settingsHasMoved = true;
                }
                
                if (settingsHasMoved) {
                    const x = e.clientX - settingsDragOffsetX;
                    const y = e.clientY - settingsDragOffsetY;
                    
                    const maxX = window.innerWidth - magnifierSettingsToggle.offsetWidth;
                    const maxY = window.innerHeight - magnifierSettingsToggle.offsetHeight;
                    
                    const boundedX = Math.max(0, Math.min(x, maxX));
                    const boundedY = Math.max(0, Math.min(y, maxY));
                    
                    magnifierSettingsToggle.style.left = boundedX + 'px';
                    magnifierSettingsToggle.style.right = 'auto';
                    magnifierSettingsToggle.style.bottom = 'auto';
                    magnifierSettingsToggle.style.top = boundedY + 'px';
                    magnifierSettingsToggle.style.position = 'fixed';
                    
                    localStorage.setItem('magnifierSettingsPos', JSON.stringify({x: boundedX, y: boundedY}));
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                if (!isSettingsDragging) return;
                
                isSettingsDragging = false;
                magnifierSettingsToggle.classList.remove('dragging');
                
                // Reset settingsHasMoved after a short delay
                setTimeout(() => {
                    settingsHasMoved = false;
                }, 100);
            });
            
            // Make Settings Panel draggable
            let isPanelDragging = false;
            let panelDragStartX = 0;
            let panelDragStartY = 0;
            let panelDragOffsetX = 0;
            let panelDragOffsetY = 0;
            let panelHasMoved = false;
            
            magnifierSettings.addEventListener('mousedown', function(e) {
                // Only drag from header or empty areas, not from interactive elements
                if (e.target.tagName === 'INPUT' || 
                    e.target.tagName === 'BUTTON' || 
                    e.target.tagName === 'LABEL' ||
                    e.target.closest('.magnifier-setting-label') ||
                    e.target.closest('input') ||
                    e.target.closest('button')) {
                    return; // Don't drag when interacting with controls
                }
                
                if (e.button !== 0) return;
                
                isPanelDragging = true;
                panelHasMoved = false;
                panelDragStartX = e.clientX;
                panelDragStartY = e.clientY;
                
                const rect = magnifierSettings.getBoundingClientRect();
                panelDragOffsetX = e.clientX - rect.left;
                panelDragOffsetY = e.clientY - rect.top;
                
                magnifierSettings.classList.add('dragging');
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isPanelDragging) return;
                
                const moveX = Math.abs(e.clientX - panelDragStartX);
                const moveY = Math.abs(e.clientY - panelDragStartY);
                
                if (moveX > 5 || moveY > 5) {
                    panelHasMoved = true;
                }
                
                if (panelHasMoved) {
                    const x = e.clientX - panelDragOffsetX;
                    const y = e.clientY - panelDragOffsetY;
                    
                    const maxX = window.innerWidth - magnifierSettings.offsetWidth;
                    const maxY = window.innerHeight - magnifierSettings.offsetHeight;
                    
                    const boundedX = Math.max(0, Math.min(x, maxX));
                    const boundedY = Math.max(0, Math.min(y, maxY));
                    
                    magnifierSettings.style.left = boundedX + 'px';
                    magnifierSettings.style.right = 'auto';
                    magnifierSettings.style.bottom = 'auto';
                    magnifierSettings.style.top = boundedY + 'px';
                    magnifierSettings.style.position = 'fixed';
                    
                    localStorage.setItem('magnifierPanelPos', JSON.stringify({x: boundedX, y: boundedY}));
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                if (!isPanelDragging) return;
                
                isPanelDragging = false;
                magnifierSettings.classList.remove('dragging');
                
                setTimeout(() => {
                    panelHasMoved = false;
                }, 100);
            });
            
            // Restore saved positions on load
            const savedTogglePos = localStorage.getItem('magnifierTogglePos');
            if (savedTogglePos) {
                const pos = JSON.parse(savedTogglePos);
                magnifierToggle.style.left = pos.x + 'px';
                magnifierToggle.style.bottom = 'auto';
                magnifierToggle.style.top = pos.y + 'px';
            }
            
            const savedSettingsPos = localStorage.getItem('magnifierSettingsPos');
            if (savedSettingsPos) {
                const pos = JSON.parse(savedSettingsPos);
                magnifierSettingsToggle.style.left = pos.x + 'px';
                magnifierSettingsToggle.style.right = 'auto';
                magnifierSettingsToggle.style.bottom = 'auto';
                magnifierSettingsToggle.style.top = pos.y + 'px';
                magnifierSettingsToggle.style.position = 'fixed';
            }
            
            const savedPanelPos = localStorage.getItem('magnifierPanelPos');
            if (savedPanelPos) {
                const pos = JSON.parse(savedPanelPos);
                magnifierSettings.style.left = pos.x + 'px';
                magnifierSettings.style.right = 'auto';
                magnifierSettings.style.bottom = 'auto';
                magnifierSettings.style.top = pos.y + 'px';
                magnifierSettings.style.position = 'fixed';
            }
            
            // ===== END DRAG & DROP =====
            
            // Click handler implementation (called from drag logic)
            magnifierToggle.addEventListener('click', function(e) {
                // Ignore if this was a drag operation (handled in mouseup)
                if (isDragging || hasMoved) {
                    e.stopPropagation();
                    return;
                }
                
                magnifierEnabled = !magnifierEnabled;
                magnifierToggle.classList.toggle('active', magnifierEnabled);
                if (!magnifierEnabled) {
                    magnifier.style.display = 'none';
                    magnifierFrozen = false;
                    magnifier.classList.remove('frozen');
                    frozenPosition = null;
                    // Schließe auch das Settings-Panel
                    magnifierSettings.classList.remove('show');
                } else {
                    // Initialize map immediately when enabled
                    if (!magnifierMap) {
                        initMagnifierMap();
                        updateMagnifierRoute();
                    }
                }
                magnifierSettingsToggle.classList.toggle('show', magnifierEnabled);
                console.log(`X-Ray Magnifier ${magnifierEnabled ? 'enabled' : 'disabled'}`);
            });
            
            // Toggle settings panel
            magnifierSettingsToggle.addEventListener('click', function(e) {
                if (isSettingsDragging || settingsHasMoved) {
                    e.stopPropagation();
                    return;
                }
                magnifierSettings.classList.toggle('show');
            });
            
            // Size slider
            const sizeSlider = document.getElementById('magSizeSlider');
            const sizeValue = document.getElementById('magSizeValue');
            sizeSlider.addEventListener('input', (e) => {
                currentSize = parseInt(e.target.value);
                sizeValue.textContent = currentSize + 'px';
                magnifier.style.width = currentSize + 'px';
                magnifier.style.height = currentSize + 'px';
                magnifierCanvas.width = currentSize;
                magnifierCanvas.height = currentSize;
                
                const mapSize = currentSize * 2;
                const mapElement = document.getElementById('magnifierMap');
                mapElement.style.width = mapSize + 'px';
                mapElement.style.height = mapSize + 'px';
                
                if (magnifierMap) {
                    magnifierMap.invalidateSize();
                }
                console.log(`Magnifier size: ${currentSize}px`);
            });
            
            // Zoom slider
            const zoomSlider = document.getElementById('magZoomSlider');
            const zoomValue = document.getElementById('magZoomValue');
            zoomSlider.addEventListener('input', (e) => {
                currentZoom = parseInt(e.target.value);
                zoomValue.textContent = '+' + currentZoom;
                console.log(`Magnifier zoom: +${currentZoom}`);
            });
            
            // Mode buttons
            const modeButtons = document.querySelectorAll('.magnifier-mode-btn[data-mode]');
            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.getAttribute('data-mode');
                    if (mode) {
                        currentMode = mode;
                        modeButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        updateMagnifierLayer();
                        console.log(`Magnifier mode: ${mode}`);
                    }
                });
            });
            
            // Feature toggles
            const featureToggles = {
                'featureRoute': 'route',
                'featureSurface': 'surface',
                'featurePOI': 'poi',
                'featureCoords': 'coords',
                'featureProfile': 'profile',
                'featureMeasure': 'measure',
                'featureSmartFocus': 'smartFocus'
            };
            
            Object.keys(featureToggles).forEach(id => {
                const element = document.getElementById(id);
                const feature = featureToggles[id];
                element.addEventListener('click', () => {
                    element.classList.toggle('active');
                    features[feature] = element.classList.contains('active');
                    console.log(`Feature ${feature}: ${features[feature]}`);
                    
                    // Update visibility
                    if (feature === 'coords') {
                        document.getElementById('magnifierCoords').style.display = features.coords ? 'block' : 'none';
                        document.getElementById('magnifierElevation').style.display = features.coords ? 'block' : 'none';
                        document.getElementById('magnifierSurface').style.display = features.coords ? 'block' : 'none';
                    }
                });
            });
            
            // Snapshot button
            document.getElementById('magSnapshot').addEventListener('click', takeSnapshot);
            
            // Toggle magnifier with 'L' key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'l' || e.key === 'L') {
                    magnifierEnabled = !magnifierEnabled;
                    magnifierToggle.classList.toggle('active', magnifierEnabled);
                    magnifierSettingsToggle.classList.toggle('show', magnifierEnabled);
                    if (!magnifierEnabled) {
                        magnifier.style.display = 'none';
                        magnifierFrozen = false;
                        magnifier.classList.remove('frozen');
                        frozenPosition = null;
                        // Schließe auch das Settings-Panel
                        magnifierSettings.classList.remove('show');
                    } else {
                        // Initialize map immediately when enabled
                        if (!magnifierMap) {
                            initMagnifierMap();
                            updateMagnifierRoute();
                        }
                    }
                    console.log(`X-Ray Magnifier ${magnifierEnabled ? 'enabled' : 'disabled'} (L key)`);
                }
                
                // Freeze with SPACE
                if (e.key === ' ' && magnifierEnabled) {
                    e.preventDefault();
                    magnifierFrozen = !magnifierFrozen;
                    magnifier.classList.toggle('frozen', magnifierFrozen);
                    
                    if (magnifierFrozen && magnifier.style.display === 'block') {
                        // Store current position
                        const rect = map.getContainer().getBoundingClientRect();
                        const magnifierRect = magnifier.getBoundingClientRect();
                        const centerX = magnifierRect.left + magnifierRect.width / 2 - rect.left;
                        const centerY = magnifierRect.top + magnifierRect.height / 2 - rect.top;
                        frozenPosition = map.containerPointToLatLng([centerX, centerY]);
                        console.log('Magnifier FROZEN at:', frozenPosition);
                    } else {
                        frozenPosition = null;
                        console.log('Magnifier UNFROZEN');
                    }
                }
                
                // Snapshot with 'S'
                if ((e.key === 's' || e.key === 'S') && magnifierEnabled && magnifier.style.display === 'block') {
                    takeSnapshot();
                }
            });
            
            // Initialize magnifier map
            function initMagnifierMap() {
                if (!magnifierMap) {
                    // Set initial map container size BEFORE creating map
                    const mapElement = document.getElementById('magnifierMap');
                    const mapSize = currentSize * 2;
                    mapElement.style.width = mapSize + 'px';
                    mapElement.style.height = mapSize + 'px';
                    
                    magnifierMap = L.map('magnifierMap', {
                        zoomControl: false,
                        attributionControl: false,
                        dragging: false,
                        scrollWheelZoom: false,
                        doubleClickZoom: false,
                        boxZoom: false,
                        keyboard: false,
                        tap: false,
                        touchZoom: false
                    });
                    
                    updateMagnifierLayer();
                    
                    // Force size recalculation after a brief delay
                    setTimeout(() => {
                        if (magnifierMap) {
                            magnifierMap.invalidateSize();
                        }
                    }, 100);
                    
                    console.log('✓ X-Ray Magnifier map initialized');
                }
            }
            
            // Update map layer based on mode
            function updateMagnifierLayer() {
                if (!magnifierMap) return;
                
                // Remove all tile layers (but keep route/markers/POI)
                magnifierMap.eachLayer(layer => {
                    if (!(layer === magnifierRouteLayer || layer === magnifierMarkersLayer || layer === magnifierPOILayer)) {
                        magnifierMap.removeLayer(layer);
                    }
                });
                
                let tileLayer;
                switch(currentMode) {
                    case 'osm':
                        tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            maxZoom: 19,
                            keepBuffer: 8,
                            updateWhenIdle: false,
                            updateWhenZooming: false
                        });
                        magnifierMap.getContainer().style.background = '';
                        break;
                    case 'satellite':
                        tileLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                            maxZoom: 19,
                            keepBuffer: 8,
                            updateWhenIdle: false,
                            updateWhenZooming: false
                        });
                        magnifierMap.getContainer().style.background = '';
                        break;
                    case 'topo':
                        tileLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                            maxZoom: 17,
                            keepBuffer: 8,
                            updateWhenIdle: false,
                            updateWhenZooming: false
                        });
                        magnifierMap.getContainer().style.background = '';
                        break;
                    case 'surface':
                        // Keep satellite but show route with surface colors
                        tileLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                            maxZoom: 19,
                            keepBuffer: 8,
                            updateWhenIdle: false,
                            updateWhenZooming: false,
                            opacity: 0.3  // Dimmed background
                        });
                        magnifierMap.getContainer().style.background = '#1a1a1a';
                        break;
                }
                
                if (tileLayer) {
                    tileLayer.addTo(magnifierMap);
                }
                
                // Re-add route with appropriate styling
                updateMagnifierRoute();
            }
            
            // Update route in magnifier
            function updateMagnifierRoute() {
                if (!magnifierMap) return;
                
                // Remove old layers
                if (magnifierRouteLayer) {
                    magnifierMap.removeLayer(magnifierRouteLayer);
                    magnifierRouteLayer = null;
                }
                if (magnifierMarkersLayer) {
                    magnifierMap.removeLayer(magnifierMarkersLayer);
                    magnifierMarkersLayer = null;
                }
                if (magnifierPOILayer) {
                    magnifierMap.removeLayer(magnifierPOILayer);
                    magnifierPOILayer = null;
                }
                
                // Add route if exists
                if (routes.length > 0 && routes[0].coordinates) {
                    // Check if we should show surface colors
                    const showSurfaceColors = currentMode === 'surface' && features.surface && window.surfaceData && window.surfaceData.length > 0;
                    
                    if (showSurfaceColors && features.route) {
                        // Multi-colored route based on surface type
                        magnifierRouteLayer = L.layerGroup();
                        
                        const coordinates = routes[0].coordinates;
                        const pointsPerSegment = Math.ceil(coordinates.length / window.surfaceData.length);
                        
                        const surfaceColors = {
                            'paved': '#10b981',
                            'asphalt': '#10b981',
                            'compacted': '#eab308',
                            'gravel': '#f97316',
                            'unpaved': '#ef4444',
                            'dirt': '#dc2626',
                            'ground': '#b91c1c',
                            'sand': '#f59e0b',
                            'unknown': '#94a3b8'
                        };
                        
                        for (let i = 0; i < window.surfaceData.length; i++) {
                            const startIdx = i * pointsPerSegment;
                            const endIdx = Math.min((i + 1) * pointsPerSegment + 1, coordinates.length);
                            const segmentCoords = coordinates.slice(startIdx, endIdx);
                            
                            if (segmentCoords.length < 2) continue;
                            
                            const surface = window.surfaceData[i];
                            const color = surfaceColors[surface] || surfaceColors['unknown'];
                            
                            const segmentLine = L.polyline(segmentCoords, {
                                color: color,
                                weight: 5,
                                opacity: features.route ? 1.0 : 0.3,  // Transparent wenn ausgeschaltet
                                dashArray: features.route ? null : '5, 10'  // Gestrichelt wenn ausgeschaltet
                            }).addTo(magnifierRouteLayer);
                        }
                        
                        magnifierRouteLayer.addTo(magnifierMap);
                    } else {
                        // Simple route - show even if features.route is off, but transparent/dashed
                        const routeColor = currentMode === 'satellite' ? '#ffffff' : '#3b82f6';
                        magnifierRouteLayer = L.polyline(routes[0].coordinates, {
                            color: routeColor,
                            weight: features.route ? 4 : 3,
                            opacity: features.route ? 0.9 : 0.3,  // Transparent wenn ausgeschaltet
                            dashArray: features.route ? null : '5, 10'  // Gestrichelt wenn ausgeschaltet
                        }).addTo(magnifierMap);
                    }
                }
                
                // Add waypoint markers - always show, but adjust visibility
                if (waypoints.length > 0) {
                    magnifierMarkersLayer = L.layerGroup();
                    
                    waypoints.forEach((wp, idx) => {
                        const color = idx === 0 ? '#10b981' : idx === waypoints.length - 1 ? '#ef4444' : '#3b82f6';
                        
                        const miniMarker = L.circleMarker([wp.lat, wp.lng], {
                            radius: features.route ? 5 : 3,  // Kleiner wenn ausgeschaltet
                            fillColor: color,
                            color: 'white',
                            weight: 2,
                            opacity: features.route ? 1 : 0.4,  // Transparenter wenn ausgeschaltet
                            fillOpacity: features.route ? 0.9 : 0.4
                        }).addTo(magnifierMarkersLayer);
                    });
                    
                    magnifierMarkersLayer.addTo(magnifierMap);
                }
                
                // Add POI layer if enabled
                if (features.poi) {
                    magnifierPOILayer = L.layerGroup();
                    
                    Object.values(poiLayers).forEach(layer => {
                        if (layer) {
                            layer.eachLayer(marker => {
                                const miniPOI = L.circleMarker(marker.getLatLng(), {
                                    radius: 8,  // Größer: 3 → 8
                                    fillColor: '#f59e0b',
                                    color: 'white',
                                    weight: 2,  // Dickerer Rand
                                    opacity: 1,
                                    fillOpacity: 0.9
                                }).addTo(magnifierPOILayer);
                            });
                        }
                    });
                    
                    magnifierPOILayer.addTo(magnifierMap);
                }
            }
            
            // Calculate surface quality at position
            function getSurfaceQuality(latlng) {
                if (!routes[0] || !routes[0].coordinates) return null;
                
                // Find closest point on route
                let minDist = Infinity;
                let closestIdx = 0;
                
                routes[0].coordinates.forEach((coord, idx) => {
                    const dist = Math.sqrt(
                        Math.pow(coord[0] - latlng.lat, 2) + 
                        Math.pow(coord[1] - latlng.lng, 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = idx;
                    }
                });
                
                // Get surface type from global data
                if (window.surfaceData && window.surfaceData.length > 0) {
                    const totalPoints = routes[0].coordinates.length;
                    const surfaceIdx = Math.floor((closestIdx / totalPoints) * window.surfaceData.length);
                    const surface = window.surfaceData[Math.min(surfaceIdx, window.surfaceData.length - 1)];
                    
                    // Calculate quality score
                    const qualityMap = {
                        'asphalt': 100, 'paved': 95,
                        'compacted': 70, 'gravel': 50,
                        'unpaved': 30, 'dirt': 20,
                        'sand': 15, 'unknown': 50
                    };
                    
                    const quality = qualityMap[surface] || 50;
                    
                    return {
                        type: surface.toUpperCase(),
                        quality: quality,
                        gradient: calculateGradient(closestIdx),
                        elevation: routes[0].elevations ? routes[0].elevations[closestIdx] : 0
                    };
                }
                
                return null;
            }
            
            function calculateGradient(idx) {
                if (!routes[0] || !routes[0].elevations) return 0;
                
                const elevations = routes[0].elevations;
                const coordinates = routes[0].coordinates;
                
                if (idx < 5 || idx >= elevations.length - 5) return 0;
                
                // Calculate gradient over 10 points (±5)
                const elevStart = elevations[idx - 5];
                const elevEnd = elevations[idx + 5];
                
                // Distance between points
                const R = 6371000; // meters
                const lat1 = coordinates[idx - 5][0] * Math.PI / 180;
                const lat2 = coordinates[idx + 5][0] * Math.PI / 180;
                const dLat = (coordinates[idx + 5][0] - coordinates[idx - 5][0]) * Math.PI / 180;
                const dLon = (coordinates[idx + 5][1] - coordinates[idx - 5][1]) * Math.PI / 180;
                
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1) * Math.cos(lat2) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const distance = R * c;
                
                if (distance === 0) return 0;
                
                return ((elevEnd - elevStart) / distance) * 100;
            }
            
            // Draw surface quality heatmap on canvas
            function drawSurfaceHeatmap(latlng) {
                if (!features.surface || !magnifierCtx) return;
                
                const surfaceInfo = getSurfaceQuality(latlng);
                if (!surfaceInfo) return;
                
                // Clear canvas
                magnifierCtx.clearRect(0, 0, currentSize, currentSize);
                
                // Create radial gradient based on quality
                const centerX = currentSize / 2;
                const centerY = currentSize / 2;
                const gradient = magnifierCtx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, currentSize / 2
                );
                
                // Color based on quality
                let color1, color2;
                if (surfaceInfo.quality >= 80) {
                    color1 = 'rgba(16, 185, 129, 0.3)'; // Green
                    color2 = 'rgba(16, 185, 129, 0)';
                } else if (surfaceInfo.quality >= 60) {
                    color1 = 'rgba(234, 179, 8, 0.3)'; // Yellow
                    color2 = 'rgba(234, 179, 8, 0)';
                } else if (surfaceInfo.quality >= 40) {
                    color1 = 'rgba(249, 115, 22, 0.3)'; // Orange
                    color2 = 'rgba(249, 115, 22, 0)';
                } else {
                    color1 = 'rgba(239, 68, 68, 0.3)'; // Red
                    color2 = 'rgba(239, 68, 68, 0)';
                }
                
                gradient.addColorStop(0, color1);
                gradient.addColorStop(1, color2);
                
                magnifierCtx.fillStyle = gradient;
                magnifierCtx.beginPath();
                magnifierCtx.arc(centerX, centerY, currentSize / 2, 0, Math.PI * 2);
                magnifierCtx.fill();
            }
            
            // Update info overlays
            function updateOverlays(latlng) {
                // Update coordinates, elevation, surface displays
                if (features.coords) {
                    const coordsEl = document.getElementById('magnifierCoords');
                    const elevEl = document.getElementById('magnifierElevation');
                    const surfaceEl = document.getElementById('magnifierSurface');
                    
                    // Update coordinates
                    coordsEl.textContent = `${latlng.lat.toFixed(5)}°N, ${latlng.lng.toFixed(5)}°E`;
                    
                    // Update surface info
                    const surfaceInfo = getSurfaceQuality(latlng);
                    if (surfaceInfo) {
                        const gradientSymbol = surfaceInfo.gradient > 1 ? '↗' : surfaceInfo.gradient < -1 ? '↘' : '→';
                        elevEl.textContent = `${Math.round(surfaceInfo.elevation)}m | ${gradientSymbol} ${Math.abs(surfaceInfo.gradient).toFixed(1)}%`;
                        surfaceEl.textContent = `${surfaceInfo.type} | Quality: ${surfaceInfo.quality}%`;
                        
                        // Color code based on quality
                        if (surfaceInfo.quality >= 80) {
                            surfaceEl.style.color = '#10b981';
                        } else if (surfaceInfo.quality >= 60) {
                            surfaceEl.style.color = '#eab308';
                        } else if (surfaceInfo.quality >= 40) {
                            surfaceEl.style.color = '#f97316';
                        } else {
                            surfaceEl.style.color = '#ef4444';
                        }
                    }
                }
                
                // Update mini profile - independent of coords feature
                updateMiniProfile(latlng);
                
                // Update measure tool - independent of coords feature
                updateMeasureTool(latlng);
            }
            
            // Mini Profile: Show elevation profile around cursor position
            function updateMiniProfile(latlng) {
                const profileCanvas = document.getElementById('magnifierMiniProfile');
                
                if (!features.profile || !routes[0] || !routes[0].elevations) {
                    profileCanvas.style.display = 'none';
                    return;
                }
                
                profileCanvas.style.display = 'block';
                const ctx = profileCanvas.getContext('2d');
                const width = currentSize;
                const height = Math.floor(currentSize / 3);  // 1/3 der Lupe
                
                // Update canvas size
                profileCanvas.width = width;
                profileCanvas.height = height;
                profileCanvas.style.height = height + 'px';
                
                // Find closest point on route
                let closestIdx = 0;
                let minDist = Infinity;
                routes[0].coordinates.forEach((coord, idx) => {
                    const dist = Math.sqrt(
                        Math.pow(coord[0] - latlng.lat, 2) + 
                        Math.pow(coord[1] - latlng.lng, 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = idx;
                    }
                });
                
                // Get elevation data around this point (±50 points)
                const range = 50;
                const startIdx = Math.max(0, closestIdx - range);
                const endIdx = Math.min(routes[0].elevations.length - 1, closestIdx + range);
                const elevData = routes[0].elevations.slice(startIdx, endIdx);
                
                if (elevData.length < 2) return;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Find min/max elevation
                const minElev = Math.min(...elevData);
                const maxElev = Math.max(...elevData);
                const elevRange = maxElev - minElev || 1;
                
                // Draw profile
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                ctx.lineWidth = 2;
                ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                
                elevData.forEach((elev, idx) => {
                    const x = (idx / (elevData.length - 1)) * width;
                    const y = height - ((elev - minElev) / elevRange) * (height - 10) - 5;
                    
                    if (idx === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                // Fill area under curve
                ctx.lineTo(width, height);
                ctx.lineTo(0, height);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Draw cursor position marker
                const cursorX = ((closestIdx - startIdx) / (elevData.length - 1)) * width;
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.9)';
                ctx.lineWidth = 2;
                ctx.moveTo(cursorX, 0);
                ctx.lineTo(cursorX, height);
                ctx.stroke();
                
                // Draw elevation text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 11px monospace';
                ctx.fillText(`${Math.round(minElev)}m`, 5, height - 5);
                ctx.fillText(`${Math.round(maxElev)}m`, 5, 14);
            }
            
            // Measure Tool: Show distance from start of route to cursor
            function updateMeasureTool(latlng) {
                const measureOverlay = document.getElementById('magnifierMeasure');
                
                if (!features.measure || !routes[0]) {
                    measureOverlay.style.display = 'none';
                    return;
                }
                
                measureOverlay.style.display = 'block';
                
                // Find closest point on route
                let closestIdx = 0;
                let minDist = Infinity;
                routes[0].coordinates.forEach((coord, idx) => {
                    const dist = Math.sqrt(
                        Math.pow(coord[0] - latlng.lat, 2) + 
                        Math.pow(coord[1] - latlng.lng, 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = idx;
                    }
                });
                
                // Calculate cumulative distance to this point
                let cumulativeDist = 0;
                for (let i = 1; i <= closestIdx; i++) {
                    const prev = routes[0].coordinates[i - 1];
                    const curr = routes[0].coordinates[i];
                    
                    // Haversine distance
                    const R = 6371;
                    const lat1 = prev[0] * Math.PI / 180;
                    const lat2 = curr[0] * Math.PI / 180;
                    const dLat = (curr[0] - prev[0]) * Math.PI / 180;
                    const dLon = (curr[1] - prev[1]) * Math.PI / 180;
                    
                    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                             Math.cos(lat1) * Math.cos(lat2) *
                             Math.sin(dLon/2) * Math.sin(dLon/2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    cumulativeDist += R * c;
                }
                
                // Show distance from start - Position unten links bei 2/3 Höhe
                const measureLabel = measureOverlay.querySelector('.measure-label');
                measureLabel.textContent = `📏 ${cumulativeDist.toFixed(2)} km`;
                measureLabel.style.left = '8px';
                measureLabel.style.right = 'auto';
                measureLabel.style.top = '66%';  // 2/3 der Höhe
                measureLabel.style.bottom = 'auto';
                measureLabel.style.transform = 'none';
                
                // Draw line from center to edge (indicating direction to start)
                const measureLine = measureOverlay.querySelector('.measure-line');
                
                if (waypoints.length > 0) {
                    const angle = Math.atan2(waypoints[0].lat - latlng.lat, waypoints[0].lng - latlng.lng);
                    const lineLength = currentSize / 3;
                    
                    measureLine.style.left = '50%';
                    measureLine.style.top = '50%';
                    measureLine.style.width = `${lineLength}px`;
                    measureLine.style.transform = `rotate(${angle}rad)`;
                    measureLine.style.display = 'block';
                } else {
                    measureLine.style.display = 'none';
                }
            }
            
            
            // Smart Focus: auto-adjust zoom based on route density
            function applySmartFocus(latlng) {
                if (!features.smartFocus || !routes[0]) return currentZoom;
                
                // Calculate route point density around cursor
                const searchRadius = 0.001; // ~100m
                let nearbyPoints = 0;
                
                routes[0].coordinates.forEach(coord => {
                    const dist = Math.sqrt(
                        Math.pow(coord[0] - latlng.lat, 2) + 
                        Math.pow(coord[1] - latlng.lng, 2)
                    );
                    if (dist < searchRadius) nearbyPoints++;
                });
                
                // More points = zoom in more for detail
                if (nearbyPoints > 50) return currentZoom + 1;
                if (nearbyPoints < 10) return currentZoom - 1;
                return currentZoom;
            }
            
            // Snapshot function
            function takeSnapshot() {
                if (!magnifierMap || magnifier.style.display !== 'block') {
                    console.log('Cannot take snapshot - magnifier not visible');
                    return;
                }
                
                // Create a temporary canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = currentSize;
                tempCanvas.height = currentSize;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Get magnifier map container
                const mapContainer = document.getElementById('magnifierMap');
                
                // Use html2canvas would be better, but let's do simple approach
                // Draw magnifier border
                tempCtx.beginPath();
                tempCtx.arc(currentSize/2, currentSize/2, currentSize/2 - 2, 0, Math.PI * 2);
                tempCtx.strokeStyle = '#3b82f6';
                tempCtx.lineWidth = 4;
                tempCtx.stroke();
                
                // Add timestamp
                tempCtx.fillStyle = '#3b82f6';
                tempCtx.font = 'bold 12px monospace';
                tempCtx.fillText(new Date().toLocaleString(), 10, currentSize - 10);
                
                // Download
                const dataUrl = tempCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = `magnifier-snapshot-${Date.now()}.png`;
                link.href = dataUrl;
                link.click();
                
                console.log('📸 Snapshot captured!');
            }
            
            // Update magnifier position and content
            map.getContainer().addEventListener('mousemove', function(e) {
                if (!magnifierEnabled) return;
                
                if (!magnifierMap) {
                    initMagnifierMap();
                    updateMagnifierRoute();
                }
                
                // Use clientX/clientY directly for fixed positioning
                const x = e.clientX;
                const y = e.clientY;
                
                // Position magnifier (fixed positioning)
                magnifier.style.left = (x - currentSize/2) + 'px';
                magnifier.style.top = (y - currentSize/2) + 'px';
                magnifier.style.display = 'block';
                
                // Get lat/lng at mouse position (or frozen position)
                const rect = map.getContainer().getBoundingClientRect();
                const mapX = e.clientX - rect.left;
                const mapY = e.clientY - rect.top;
                
                let latlng;
                if (magnifierFrozen && frozenPosition) {
                    latlng = frozenPosition;
                } else {
                    latlng = map.containerPointToLatLng([mapX, mapY]);
                }
                
                // Apply smart focus
                const zoomLevel = applySmartFocus(latlng);
                const actualZoom = map.getZoom() + zoomLevel;
                
                // Update magnifier map - CRITICAL: force invalidateSize for smooth loading
                magnifierMap.setView(latlng, actualZoom, { animate: false });
                magnifierMap.invalidateSize(false);
                
                // Draw surface heatmap
                drawSurfaceHeatmap(latlng);
                
                // Update overlays
                updateOverlays(latlng);
            });
            
            // Hide magnifier when leaving map
            map.getContainer().addEventListener('mouseleave', function() {
                if (!magnifierFrozen) {
                    magnifier.style.display = 'none';
                }
            });
            
            // Listen for route updates
            window.updateMagnifierRoute = updateMagnifierRoute;
            
            console.log('✓ X-Ray Magnifier initialized with all features');
        }
        
        async function togglePOI(type, button) {
            const isActive = button.classList.contains('active');
            
            if (isActive) {
                button.classList.remove('active');
                if (poiLayers[type]) {
                    map.removeLayer(poiLayers[type]);
                    poiLayers[type] = null;
                }
                console.log(`✓ ${type} POIs deactivated`);
            } else {
                button.classList.add('active');
                await loadPOI(type, button);
            }
        }
        
        // Calculate distance between two lat/lon points in km (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in km
        }
        
        async function loadPOI(type, button) {
            // Check if route exists
            if (routes.length === 0 || !routes[0].coordinates) {
                alert('Bitte zuerst eine Route berechnen oder GPX-Datei laden.');
                button.classList.remove('active');
                return;
            }
            
            const routeCoordinates = routes[0].coordinates;
            
            // Create bounding box around route with buffer
            let minLat = Infinity, maxLat = -Infinity;
            let minLon = Infinity, maxLon = -Infinity;
            
            routeCoordinates.forEach(coord => {
                minLat = Math.min(minLat, coord[0]);
                maxLat = Math.max(maxLat, coord[0]);
                minLon = Math.min(minLon, coord[1]);
                maxLon = Math.max(maxLon, coord[1]);
            });
            
            // Add small buffer to bbox (0.01 degrees ≈ 1km)
            const buffer = 0.01;
            const bbox = `${minLat - buffer},${minLon - buffer},${maxLat + buffer},${maxLon + buffer}`;
            
            let query = '';
            let icon = '';
            let color = '';
            let typeName = '';
            
            switch(type) {
                case 'water':
                    query = `[out:json][timeout:25];(node["amenity"="drinking_water"](${bbox});node["man_made"="water_tap"](${bbox}););out body;`;
                    icon = '💧';
                    color = '#3b82f6';
                    typeName = 'Trinkwasser';
                    break;
                case 'cafe':
                    query = `[out:json][timeout:25];(node["amenity"="cafe"](${bbox});node["amenity"="restaurant"](${bbox});node["amenity"="fast_food"](${bbox}););out body;`;
                    icon = '☕';
                    color = '#92400e';
                    typeName = 'Cafés';
                    break;
                case 'shop':
                    query = `[out:json][timeout:25];(node["shop"="convenience"](${bbox});node["shop"="supermarket"](${bbox});node["shop"="kiosk"](${bbox}););out body;`;
                    icon = '🛒';
                    color = '#059669';
                    typeName = 'Shops';
                    break;
                case 'bike':
                    query = `[out:json][timeout:25];(node["shop"="bicycle"](${bbox});node["amenity"="bicycle_repair_station"](${bbox}););out body;`;
                    icon = '🔧';
                    color = '#dc2626';
                    typeName = 'Fahrradläden';
                    break;
            }
            
            try {
                console.log(`Loading ${type} POIs along route...`);
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.elements || data.elements.length === 0) {
                    console.log(`No ${type} POIs found near route`);
                    alert(`Keine ${typeName} entlang der Route gefunden.`);
                    button.classList.remove('active');
                    return;
                }
                
                // Filter POIs: only keep those within 50m of route
                const MAX_DISTANCE = 0.05; // 50 meters in km
                const filteredPOIs = data.elements.filter(element => {
                    if (!element.lat || !element.lon) return false;
                    
                    // Check if POI is within 50m of any route point
                    for (const coord of routeCoordinates) {
                        const distance = calculateDistance(
                            element.lat, element.lon,
                            coord[0], coord[1]
                        );
                        
                        if (distance <= MAX_DISTANCE) {
                            return true; // POI is close enough
                        }
                    }
                    
                    return false; // POI too far from route
                });
                
                if (filteredPOIs.length === 0) {
                    console.log(`No ${type} POIs within 50m of route`);
                    alert(`Keine ${typeName} in der Nähe der Route gefunden (max. 50m Abstand).`);
                    button.classList.remove('active');
                    return;
                }
                
                console.log(`✓ Found ${filteredPOIs.length} ${type} POIs along route (from ${data.elements.length} total)`);
                
                const layerGroup = L.layerGroup();
                
                filteredPOIs.forEach(element => {
                    const poiIcon = L.divIcon({
                        className: 'poi-marker',
                        html: `<div style="background: ${color}; color: white; padding: 4px 6px; border-radius: 50%; font-size: 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 2px solid white;">${icon}</div>`,
                        iconSize: [30, 30],
                        iconAnchor: [15, 15]
                    });
                    
                    const marker = L.marker([element.lat, element.lon], {
                        icon: poiIcon
                    });
                    
                    const name = element.tags.name || 'Unbenannt';
                    const amenity = element.tags.amenity || element.tags.shop || '';
                    marker.bindPopup(`<b>${icon} ${name}</b>${amenity ? '<br><small>' + amenity + '</small>' : ''}`);
                    
                    marker.addTo(layerGroup);
                });
                
                layerGroup.addTo(map);
                poiLayers[type] = layerGroup;
                
                console.log(`✓ ${data.elements.length} ${type} POIs geladen`);
                
            } catch (error) {
                console.error(`Fehler beim Laden von ${type} POIs:`, error);
                alert(`Konnte ${typeName} nicht laden. Bitte erneut versuchen.`);
                button.classList.remove('active');
            }
        }
        
        function addWaypoint(lat, lng) {
            waypoints.push({ lat, lng });
            
            const getColor = (idx, total) => {
                if (idx === 0) return 'green';
                if (idx === total - 1) return 'red';
                return 'blue';
            };
            
            const color = getColor(waypoints.length - 1, waypoints.length);
            const number = waypoints.length;
            
            const icon = L.divIcon({
                className: 'custom-marker',
                html: `<div style="position: relative;">
                    <div style="background-color: ${color}; width: 25px; height: 25px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>
                    <div style="position: absolute; top: 4px; left: 50%; transform: translateX(-50%) rotate(45deg); color: white; font-weight: bold; font-size: 11px; text-shadow: 0 0 2px rgba(0,0,0,0.5);">${number}</div>
                </div>`,
                iconSize: [25, 25],
                iconAnchor: [12, 24],
                popupAnchor: [0, -24]
            });
            
            const marker = L.marker([lat, lng], { icon, draggable: true }).addTo(map);
            marker.bindPopup(`<b>Wegpunkt ${number}</b><br>${lat.toFixed(5)}°, ${lng.toFixed(5)}°`);
            
            marker.on('dragend', e => { 
                const idx = markers.indexOf(marker);
                waypoints[idx] = { lat: e.target.getLatLng().lat, lng: e.target.getLatLng().lng }; 
                updateList();
                clearRoutes();
            });
            
            markers.push(marker);
            updateList();
            updateButtons();
            updateMarkerColors();
        }
        
        function updateMarkerColors() {
            markers.forEach((marker, idx) => {
                const getColor = (i, total) => {
                    if (i === 0) return 'green';
                    if (i === total - 1) return 'red';
                    return 'blue';
                };
                
                const color = getColor(idx, markers.length);
                const number = idx + 1;
                
                const icon = L.divIcon({
                    className: 'custom-marker',
                    html: `<div style="position: relative;">
                        <div style="background-color: ${color}; width: 25px; height: 25px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>
                        <div style="position: absolute; top: 4px; left: 50%; transform: translateX(-50%) rotate(45deg); color: white; font-weight: bold; font-size: 11px; text-shadow: 0 0 2px rgba(0,0,0,0.5);">${number}</div>
                    </div>`,
                    iconSize: [25, 25],
                    iconAnchor: [12, 24],
                    popupAnchor: [0, -24]
                });
                
                marker.setIcon(icon);
                marker.setPopupContent(`<b>Wegpunkt ${number}</b><br>${waypoints[idx].lat.toFixed(5)}°, ${waypoints[idx].lng.toFixed(5)}°`);
            });
        }
        
        function updateList() {
            document.getElementById('waypointList').innerHTML = waypoints.map((wp, i) => 
                `<div class="waypoint-item"><div class="waypoint-number">${i+1}</div><div class="waypoint-coords">${wp.lat.toFixed(4)}°, ${wp.lng.toFixed(4)}°</div><span class="waypoint-remove" onclick="removeWaypoint(${i})">✕</span></div>`
            ).join('');
        }
        
        function removeWaypoint(idx) {
            waypoints.splice(idx, 1);
            map.removeLayer(markers[idx]);
            markers.splice(idx, 1);
            updateList();
            updateButtons();
            updateMarkerColors();
            clearRoutes();
        }
        
        function updateButtons() {
            document.getElementById('calculateBtn').disabled = waypoints.length < 2;
            document.getElementById('reverseBtn').disabled = waypoints.length < 2;
            document.getElementById('exportBtn').disabled = routes.length === 0;
            document.getElementById('saveBtn').disabled = routes.length === 0;
        }
        
        function clearRoutes() {
            routeLines.forEach(line => map.removeLayer(line));
            routeLines = [];
            routes = [];
            document.getElementById('statsPanel').classList.remove('show');
            document.getElementById('statsToggle').classList.remove('show', 'active');
            
            // Update magnifier
            if (typeof window.updateMagnifierRoute === 'function') {
                window.updateMagnifierRoute();
            }
            
            // Hide elevation profile and toggle
            hideElevationProfile();
            document.getElementById('elevationToggle').classList.remove('show', 'active');
        }
        
        async function calculateRoutes() {
            if (waypoints.length < 2) return;
            
            const currentZoom = map.getZoom();
            const currentCenter = map.getCenter();
            
            clearRoutes();
            document.getElementById('loading').classList.add('show');
            document.getElementById('calculateBtn').disabled = true;
            
            try {
                let totalDist = 0, allCoords = [], allGeometry = [], allElevations = [];
                
                for (let i = 0; i < waypoints.length - 1; i++) {
                    const start = waypoints[i], end = waypoints[i + 1];
                    const segmentKey = `${i}-${i+1}`;
                    
                    // Check for segment-specific override, otherwise use global engine
                    const engineForSegment = segmentOverrides[segmentKey] || currentEngine;
                    
                    console.log(`📍 Segment ${segmentKey}: Using engine "${engineForSegment}"`);
                    
                    let route;
                    
                    // Engine selection logic
                    if (engineForSegment === 'direct') {
                        route = getDirectRoute(start, end);
                        console.log(`✓ Segment ${segmentKey}: Direct line (${route.distance.toFixed(2)}km)`);
                    } else if (engineForSegment === 'auto') {
                        // Auto mode: try in fallback order
                        route = await getBRouterRoute(start, end, i);
                        
                        if (!route && apiKeys.graphhopper) {
                            console.log(`⚠ BRouter failed for segment ${segmentKey}, trying GraphHopper...`);
                            route = await getGraphHopperRoute(start, end, i);
                        }
                        
                        if (!route && apiKeys.valhalla) {
                            console.log(`⚠ GraphHopper failed for segment ${segmentKey}, trying Valhalla...`);
                            route = await getValhallaRoute(start, end, i);
                        }
                        
                        if (!route) {
                            console.log(`⚠ Valhalla failed for segment ${segmentKey}, trying OSRM...`);
                            route = await getOSRMRoute(start, end, i);
                        }
                    } else {
                        // Manual engine selection
                        switch(engineForSegment) {
                            case 'brouter':
                                route = await getBRouterRoute(start, end, i);
                                break;
                            case 'graphhopper':
                                if (apiKeys.graphhopper) {
                                    route = await getGraphHopperRoute(start, end, i);
                                } else {
                                    alert(`GraphHopper API Key fehlt für Segment ${segmentKey}!\nBitte in Einstellungen eingeben oder andere Engine wählen.`);
                                    document.getElementById('loading').classList.remove('show');
                                    document.getElementById('calculateBtn').disabled = false;
                                    return;
                                }
                                break;
                            case 'valhalla':
                                if (apiKeys.valhalla) {
                                    route = await getValhallaRoute(start, end, i);
                                } else {
                                    alert(`Valhalla API Key fehlt für Segment ${segmentKey}!\nBitte in Einstellungen eingeben oder andere Engine wählen.`);
                                    document.getElementById('loading').classList.remove('show');
                                    document.getElementById('calculateBtn').disabled = false;
                                    return;
                                }
                                break;
                            case 'osrm':
                                route = await getOSRMRoute(start, end, i);
                                break;
                        }
                    }
                    
                    if (!route) {
                        alert(`❌ Routing fehlgeschlagen für Segment ${i + 1} → ${i + 2}\n\nEngine: ${engineForSegment}\n\nTipp: Rechtsklick auf Route-Segment um andere Engine zu wählen.`);
                        document.getElementById('loading').classList.remove('show');
                        document.getElementById('calculateBtn').disabled = false;
                        return;
                    }
                    
                    totalDist += route.distance;
                    
                    const startIdx = i === 0 ? 0 : 1;
                    for (let j = startIdx; j < route.coordinates.length; j++) {
                        allCoords.push(route.coordinates[j]);
                        allGeometry.push(route.geometry[j]);
                        // Collect elevations from routing engine if available
                        if (route.elevations && j < route.elevations.length) {
                            allElevations.push(route.elevations[j]);
                        } else {
                            allElevations.push(null); // Mark as missing
                        }
                    }
                }
                
                // Use BRouter elevations if available, otherwise fetch from API
                let elevations;
                const hasBRouterElevations = allElevations.filter(e => e !== null).length > allElevations.length * 0.5;
                
                console.log(`📊 Elevation check: ${allElevations.filter(e => e !== null).length}/${allElevations.length} points have data`);
                
                if (hasBRouterElevations) {
                    // Fill in missing values with interpolation
                    elevations = allElevations.map((e, i) => {
                        if (e !== null) return e;
                        // Find nearest non-null values
                        let before = 500, after = 500;
                        for (let j = i - 1; j >= 0; j--) {
                            if (allElevations[j] !== null) { before = allElevations[j]; break; }
                        }
                        for (let j = i + 1; j < allElevations.length; j++) {
                            if (allElevations[j] !== null) { after = allElevations[j]; break; }
                        }
                        return (before + after) / 2;
                    });
                    console.log(`✓ Using ${allElevations.filter(e => e !== null).length} routing engine elevations (${elevations.length} total)`);
                } else {
                    console.log('⚠ Routing engine elevations not sufficient, trying external API...');
                    elevations = await getElevations(allGeometry);
                }
                const stats = calculateElevationStats(elevations);
                
                routes = [{ 
                    distance: totalDist / 1000, 
                    coordinates: allCoords, 
                    geometry: allGeometry,
                    elevations: elevations,
                    stats: stats
                }];
                
                // Function to draw route with surface colors
                function drawRouteOnMap(withSurfaceColors = false) {
                    // Remove old route lines
                    routeLines.forEach(line => map.removeLayer(line));
                    routeLines = [];
                    
                    if (!withSurfaceColors || !window.surfaceData || window.surfaceData.length === 0) {
                        // Draw single blue line
                        const line = L.polyline(allCoords, { color: '#2563eb', weight: 5, opacity: 0.8 }).addTo(map);
                        line.bindPopup(`<b>Route</b><br>${(totalDist/1000).toFixed(2)} km<br><small>Ziehe die Linie zum Anpassen</small>`);
                        routeLines.push(line);
                        return line;
                    }
                    
                    // Draw multi-colored line segments
                    const surfaceColors = {
                        'paved': '#10b981',
                        'asphalt': '#10b981',
                        'compacted': '#eab308',
                        'gravel': '#f97316',
                        'unpaved': '#ef4444',
                        'dirt': '#dc2626',
                        'ground': '#b91c1c',
                        'sand': '#f59e0b',
                        'unknown': '#94a3b8'
                    };
                    
                    // Calculate points per surface segment
                    const pointsPerSegment = Math.ceil(allCoords.length / window.surfaceData.length);
                    
                    for (let i = 0; i < window.surfaceData.length; i++) {
                        const startIdx = i * pointsPerSegment;
                        const endIdx = Math.min((i + 1) * pointsPerSegment + 1, allCoords.length);
                        const segmentCoords = allCoords.slice(startIdx, endIdx);
                        
                        if (segmentCoords.length < 2) continue;
                        
                        const surface = window.surfaceData[i];
                        const color = surfaceColors[surface] || surfaceColors['unknown'];
                        
                        const segmentLine = L.polyline(segmentCoords, {
                            color: color,
                            weight: 5,
                            opacity: 0.8
                        }).addTo(map);
                        
                        routeLines.push(segmentLine);
                    }
                    
                    // Add popup to first segment
                    if (routeLines.length > 0) {
                        routeLines[0].bindPopup(`<b>Route</b><br>${(totalDist/1000).toFixed(2)} km<br><small>Surface-Farben aktiv</small>`);
                    }
                    
                    return routeLines[0];
                }
                
                // Draw initial route (blue)
                const line = drawRouteOnMap(false);
                
                // Store redraw function globally for surface toggle
                window.redrawMapRoute = drawRouteOnMap;
                
                // Add right-click handler for segment engine selection
                // We'll add handlers to individual segments based on waypoints
                for (let i = 0; i < waypoints.length - 1; i++) {
                    const segmentKey = `${i}-${i+1}`;
                    const segmentStart = waypoints[i];
                    const segmentEnd = waypoints[i+1];
                    
                    // Create invisible wider line for easier right-clicking
                    const clickableLine = L.polyline(
                        [
                            [segmentStart.lat, segmentStart.lng],
                            [segmentEnd.lat, segmentEnd.lng]
                        ],
                        {
                            color: 'transparent',
                            weight: 20, // Wide for easier clicking
                            opacity: 0,
                            interactive: true,
                            segmentIndex: segmentKey
                        }
                    ).addTo(map);
                    
                    clickableLine.on('contextmenu', function(e) {
                        L.DomEvent.preventDefault(e.originalEvent);
                        L.DomEvent.stopPropagation(e.originalEvent);
                        showSegmentMenu(this.options.segmentIndex, e.latlng);
                    });
                    
                    routeLines.push(clickableLine);
                }
                
                let isDragging = false, dragMarker = null, dragSegmentIndex = -1, mouseDownPos = null;
                
                line.on('mousedown', function(e) {
                    mouseDownPos = e.latlng;
                    isDragging = false;
                    dragSegmentIndex = findClosestSegment(e.latlng);
                    L.DomEvent.preventDefault(e.originalEvent);
                    L.DomEvent.stopPropagation(e.originalEvent);
                });
                
                map.on('mousemove', function(e) {
                    if (mouseDownPos && !isDragging) {
                        const dist = map.distance(mouseDownPos, e.latlng);
                        if (dist > 10) {
                            isDragging = true;
                            dragMarker = L.marker([e.latlng.lat, e.latlng.lng], {
                                icon: L.divIcon({
                                    html: '<div style="background: #f59e0b; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 3px 10px rgba(0,0,0,0.4); cursor: move;"></div>',
                                    iconSize: [20, 20],
                                    iconAnchor: [10, 10]
                                })
                            }).addTo(map);
                        }
                    }
                    
                    if (isDragging && dragMarker) {
                        dragMarker.setLatLng(e.latlng);
                    }
                });
                
                map.on('mouseup', function(e) {
                    if (isDragging && dragMarker) {
                        const newPoint = e.latlng;
                        map.removeLayer(dragMarker);
                        
                        if (dragSegmentIndex >= 0 && dragSegmentIndex < waypoints.length - 1) {
                            const newWaypoint = { lat: newPoint.lat, lng: newPoint.lng };
                            waypoints.splice(dragSegmentIndex + 1, 0, newWaypoint);
                            
                            const icon = L.divIcon({
                                className: 'custom-marker',
                                html: `<div style="position: relative;">
                                    <div style="background-color: orange; width: 25px; height: 25px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>
                                    <div style="position: absolute; top: 4px; left: 50%; transform: translateX(-50%) rotate(45deg); color: white; font-weight: bold; font-size: 11px; text-shadow: 0 0 2px rgba(0,0,0,0.5);">${dragSegmentIndex + 2}</div>
                                </div>`,
                                iconSize: [25, 25],
                                iconAnchor: [12, 24],
                                popupAnchor: [0, -24]
                            });
                            
                            const marker = L.marker([newPoint.lat, newPoint.lng], { icon, draggable: true }).addTo(map);
                            marker.bindPopup(`<b>Anpassung (Punkt ${dragSegmentIndex + 2})</b><br>${newPoint.lat.toFixed(5)}°, ${newPoint.lng.toFixed(5)}°`);
                            
                            marker.on('dragend', function(e) {
                                const idx = markers.indexOf(marker);
                                waypoints[idx] = { lat: e.target.getLatLng().lat, lng: e.target.getLatLng().lng };
                                marker.setPopupContent(`<b>Wegpunkt ${idx + 1}</b><br>${waypoints[idx].lat.toFixed(5)}°, ${waypoints[idx].lng.toFixed(5)}°`);
                                updateList();
                                setTimeout(() => calculateRoutes(), 500);
                            });
                            
                            markers.splice(dragSegmentIndex + 1, 0, marker);
                            updateList();
                            updateMarkerColors();
                            setTimeout(() => calculateRoutes(), 500);
                        }
                    }
                    
                    isDragging = false;
                    dragMarker = null;
                    mouseDownPos = null;
                });
                
                line.on('mouseover', function() {
                    line.setStyle({ weight: 7, opacity: 1 });
                    map.getContainer().style.cursor = 'move';
                });
                
                line.on('mouseout', function() {
                    line.setStyle({ weight: 5, opacity: 0.8 });
                    map.getContainer().style.cursor = '';
                });
                
                routeLines.push(line);
                
                map.setView(currentCenter, currentZoom, { animate: false });
                
                // Stats content will be shown via toggle buttons
                const time = (totalDist / 1000) / averageSpeed;
                
                document.getElementById('statsContent').innerHTML = `
                    <div class="stats-highlight">
                        <div class="stat-item"><span class="stat-label">📏 Distanz:</span><span class="stat-value">${(totalDist/1000).toFixed(2)} km</span></div>
                        <div class="stat-item"><span class="stat-label">⏱️ Zeit:</span><span class="stat-value">${Math.floor(time)}:${Math.round((time%1)*60).toString().padStart(2,'0')} h</span></div>
                        <div class="stat-item"><span class="stat-label">🚴 Speed:</span><span class="stat-value">${averageSpeed} km/h</span></div>
                    </div>
                    <div class="stat-item"><span class="stat-label">📊 Höhenmeter:</span><span class="stat-value">${stats.elevationGain} m</span></div>
                    <div class="stat-item"><span class="stat-label">⛰️ Anstieg:</span><span class="stat-value">${stats.elevationGain} m</span></div>
                    <div class="stat-item"><span class="stat-label">⛷️ Abstieg:</span><span class="stat-value">${stats.elevationLoss} m</span></div>
                    <div class="stat-item"><span class="stat-label">🏔️ Max:</span><span class="stat-value">${stats.maxElevation} m</span></div>
                    <div class="stat-item"><span class="stat-label">🏞️ Min:</span><span class="stat-value">${stats.minElevation} m</span></div>
                `;
                
                updateButtons();
                console.log(`✓ Route berechnet: ${(totalDist/1000).toFixed(2)} km`);
                
                // Update magnifier if it exists
                if (typeof window.updateMagnifierRoute === 'function') {
                    window.updateMagnifierRoute();
                }
                
                // Show elevation profile
                showElevationProfile();
                
                // Show toggle buttons
                document.getElementById('statsToggle').classList.add('show');
                document.getElementById('elevationToggle').classList.add('show');
                
                // Auto-show both panels
                document.getElementById('statsPanel').classList.add('show');
                document.getElementById('statsToggle').classList.add('active');
                document.getElementById('elevationProfile').classList.add('show');
                document.getElementById('elevationToggle').classList.add('active');
                
                // Analyze surface
                analyzeSurface(allGeometry).then(surfaceData => {
                    if (surfaceData) {
                        const difficultyInfo = getDifficultyLabel(surfaceData.difficulty);
                        
                        // Add surface analysis to stats
                        const surfaceHTML = `
                            <div class="stat-item" style="margin-top: 8px; padding-top: 8px; border-top: 2px solid #e2e8f0;">
                                <span class="stat-label">Schwierigkeit:</span>
                                <span class="stat-value" style="color: ${difficultyInfo.color}">${difficultyInfo.emoji} ${difficultyInfo.label}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">🛣️ Asphalt:</span>
                                <span class="stat-value">${surfaceData.paved}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">🚵 Schotter:</span>
                                <span class="stat-value">${surfaceData.gravel}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">🌲 Trail:</span>
                                <span class="stat-value">${surfaceData.trail}%</span>
                            </div>
                            <div class="stat-item" style="background: linear-gradient(135deg, #fef3c7, #fde68a); padding: 4px 6px; border-radius: 4px; margin-top: 4px;">
                                <span class="stat-label">Gravel-Score:</span>
                                <span class="stat-value" style="color: #92400e">${surfaceData.gravelScore}%</span>
                            </div>
                        `;
                        
                        document.getElementById('statsContent').innerHTML += surfaceHTML;
                        
                        console.log(`✓ Surface analysis: ${surfaceData.paved}% paved, ${surfaceData.gravel}% gravel, ${surfaceData.trail}% trail`);
                    }
                });
                
            } catch (e) {
                alert('Fehler: ' + e.message);
                console.error(e);
            } finally {
                document.getElementById('loading').classList.remove('show');
                document.getElementById('calculateBtn').disabled = false;
            }
        }
        
        async function getBRouterRoute(start, end, segmentIndex) {
            try {
                const url = 'https://brouter.de/brouter';
                const lonlats = `${start.lng},${start.lat}|${end.lng},${end.lat}`;
                
                const R = 6371;
                const dLat = (end.lat - start.lat) * Math.PI / 180;
                const dLon = (end.lng - start.lng) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) + 
                         Math.cos(start.lat * Math.PI / 180) * Math.cos(end.lat * Math.PI / 180) * 
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const distance = R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                let profile;
                if (distance < 2 && currentProfile === 'gravel') {
                    profile = 'hiking-mountain';
                } else {
                    profile = currentProfile === 'gravel' ? 'gravel' : 'fastbike';
                }
                
                // Try to request alternative routes from BRouter
                const params = new URLSearchParams({
                    lonlats: lonlats,
                    profile: profile,
                    alternativeidx: '0',
                    format: 'geojson'
                });
                
                // Note: BRouter's 'fastbike' profile already prefers paved roads
                // but may still include some unpaved sections if no paved alternative exists
                
                const response = await fetch(`${url}?${params.toString()}`, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });
                
                if (!response.ok) {
                    console.warn(`BRouter failed for segment ${segmentIndex + 1}`);
                    return null;
                }
                
                const data = await response.json();
                
                if (!data.features || data.features.length === 0) {
                    return null;
                }
                
                // BRouter doesn't always return multiple alternatives via alternativeidx parameter
                // Instead, try making multiple requests with different alternativeidx values
                const alternatives = [data.features[0]];
                
                // Try fetching alternatives 1 and 2
                for (let altIdx = 1; altIdx <= 2; altIdx++) {
                    try {
                        const altParams = new URLSearchParams({
                            lonlats: lonlats,
                            profile: profile,
                            alternativeidx: altIdx.toString(),
                            format: 'geojson'
                        });
                        
                        const altResponse = await fetch(`${url}?${altParams.toString()}`, {
                            method: 'GET',
                            headers: { 'Accept': 'application/json' }
                        });
                        
                        if (altResponse.ok) {
                            const altData = await altResponse.json();
                            if (altData.features && altData.features.length > 0) {
                                alternatives.push(altData.features[0]);
                            }
                        }
                    } catch (e) {
                        // Alternative not available, continue
                    }
                }
                
                console.log(`✓ BRouter fetched ${alternatives.length} alternative routes`);
                
                // Analyze all alternatives and pick best based on elevation preference
                let bestRoute = null;
                let bestScore = currentElevationPref === 'flat' ? Infinity : -Infinity;
                
                for (const feature of alternatives) {
                    const coords = feature.geometry.coordinates;
                    const elevations = coords.map(c => c[2] || 0);
                    
                    // Calculate total elevation gain
                    let elevationGain = 0;
                    for (let i = 1; i < elevations.length; i++) {
                        const diff = elevations[i] - elevations[i - 1];
                        if (diff > 0) elevationGain += diff;
                    }
                    
                    // Select best route based on preference
                    if (currentElevationPref === 'flat' && elevationGain < bestScore) {
                        bestScore = elevationGain;
                        bestRoute = feature;
                    } else if (currentElevationPref === 'hilly' && elevationGain > bestScore) {
                        bestScore = elevationGain;
                        bestRoute = feature;
                    }
                }
                
                // Fallback to first route if no alternatives
                if (!bestRoute) {
                    bestRoute = alternatives[0];
                }
                
                const coords = bestRoute.geometry.coordinates;
                const routeDistance = parseFloat(bestRoute.properties['track-length']) || 0;
                
                console.log(`✓ BRouter ${profile} (${currentElevationPref}: ${Math.round(bestScore)}m gain, ${alternatives.length} alternatives) → Segment ${segmentIndex + 1}`);
                
                if (currentProfile === 'road') {
                    console.log('ℹ️ Note: BRouter may include some unpaved sections. For pure road routes, consider using GraphHopper with API key.');
                }
                
                // Extract elevations from coordinates (BRouter provides [lon, lat, elevation])
                const elevations = coords.map(c => c[2] || 0);
                
                return {
                    distance: routeDistance,
                    coordinates: coords.map(c => [c[1], c[0]]),
                    geometry: coords,
                    elevations: elevations  // Add elevations from BRouter
                };
                
            } catch (error) {
                console.warn(`BRouter error for segment ${segmentIndex + 1}:`, error);
                return null;
            }
        }
        
        function findClosestSegment(clickPoint) {
            let closestIndex = 0;
            let minDistance = Infinity;
            
            for (let i = 0; i < waypoints.length - 1; i++) {
                const segmentStart = waypoints[i];
                const segmentEnd = waypoints[i + 1];
                
                const midLat = (segmentStart.lat + segmentEnd.lat) / 2;
                const midLng = (segmentStart.lng + segmentEnd.lng) / 2;
                
                const R = 6371;
                const dLat = (clickPoint.lat - midLat) * Math.PI / 180;
                const dLon = (clickPoint.lng - midLng) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) + 
                         Math.cos(midLat * Math.PI / 180) * Math.cos(clickPoint.lat * Math.PI / 180) * 
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const dist = R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                if (dist < minDistance) {
                    minDistance = dist;
                    closestIndex = i;
                }
            }
            
            return closestIndex;
        }
        
        async function getElevations(coordinates) {
            const elevations = [];
            const batchSize = 100;
            
            for (let i = 0; i < coordinates.length; i += batchSize) {
                const batch = coordinates.slice(i, i + batchSize);
                const locations = batch.map(c => ({ latitude: c[1], longitude: c[0] }));
                
                try {
                    const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ locations })
                    });
                    const data = await response.json();
                    elevations.push(...data.results.map(r => r.elevation || 0));
                } catch (error) {
                    console.warn('Elevation data unavailable:', error);
                    elevations.push(...Array(batch.length).fill(500));
                }
            }
            
            return elevations;
        }
        
        function calculateElevationStats(elevations) {
            let elevationGain = 0;
            let elevationLoss = 0;
            
            const validElevations = elevations.filter(e => e && e > 0);
            
            // Step 1: Apply smoothing to reduce GPS noise
            // Use simple moving average with window of 5 points
            const smoothed = [];
            const windowSize = 5;
            
            for (let i = 0; i < elevations.length; i++) {
                let sum = 0;
                let count = 0;
                
                for (let j = Math.max(0, i - windowSize); j <= Math.min(elevations.length - 1, i + windowSize); j++) {
                    sum += elevations[j];
                    count++;
                }
                
                smoothed.push(sum / count);
            }
            
            // Step 2: Use higher threshold to only count significant elevation changes
            // Professional cycling computers typically use 5-10m threshold
            const ELEVATION_THRESHOLD = 8; // 8m is good compromise
            
            let cumulativeUp = 0;
            let cumulativeDown = 0;
            
            for (let i = 1; i < smoothed.length; i++) {
                const diff = smoothed[i] - smoothed[i - 1];
                
                if (diff > 0) {
                    cumulativeUp += diff;
                    
                    // When direction changes, check if we accumulated enough
                    if (i + 1 < smoothed.length && smoothed[i + 1] - smoothed[i] < 0) {
                        if (cumulativeUp >= ELEVATION_THRESHOLD) {
                            elevationGain += cumulativeUp;
                        }
                        cumulativeUp = 0;
                    }
                } else if (diff < 0) {
                    cumulativeDown += Math.abs(diff);
                    
                    // When direction changes, check if we accumulated enough
                    if (i + 1 < smoothed.length && smoothed[i + 1] - smoothed[i] > 0) {
                        if (cumulativeDown >= ELEVATION_THRESHOLD) {
                            elevationLoss += cumulativeDown;
                        }
                        cumulativeDown = 0;
                    }
                }
            }
            
            // Add any remaining accumulated elevation
            if (cumulativeUp >= ELEVATION_THRESHOLD) {
                elevationGain += cumulativeUp;
            }
            if (cumulativeDown >= ELEVATION_THRESHOLD) {
                elevationLoss += cumulativeDown;
            }
            
            console.log(`📊 Elevation stats (smoothed, ${ELEVATION_THRESHOLD}m threshold): +${Math.round(elevationGain)}m / -${Math.round(elevationLoss)}m`);
            
            return {
                elevationGain: Math.round(elevationGain),
                elevationLoss: Math.round(elevationLoss),
                maxElevation: validElevations.length > 0 ? Math.round(Math.max(...validElevations)) : 0,
                minElevation: validElevations.length > 0 ? Math.round(Math.min(...validElevations)) : 0
            };
        }
        
        async function getOSRMRoute(start, end, segmentIndex) {
            try {
                const url = `https://router.project-osrm.org/route/v1/bike/${start.lng},${start.lat};${end.lng},${end.lat}`;
                const params = new URLSearchParams({
                    geometries: 'geojson',
                    overview: 'full'
                });
                
                const response = await fetch(`${url}?${params.toString()}`);
                const data = await response.json();
                
                if (data.code !== 'Ok') {
                    console.error(`OSRM failed for segment ${segmentIndex + 1}`);
                    return null;
                }
                
                const coords = data.routes[0].geometry.coordinates;
                console.log(`✓ OSRM (fallback) → Segment ${segmentIndex + 1}`);
                
                return {
                    distance: data.routes[0].distance,
                    coordinates: coords.map(c => [c[1], c[0]]),
                    geometry: coords
                };
                
            } catch (error) {
                console.error(`OSRM error for segment ${segmentIndex + 1}:`, error);
                return null;
            }
        }
        
        async function getGraphHopperRoute(start, end, segmentIndex) {
            if (!apiKeys.graphhopper) {
                console.log('⚠ GraphHopper API key not set');
                return null;
            }
            
            try {
                const url = 'https://graphhopper.com/api/1/route';
                const params = new URLSearchParams({
                    point: `${start.lat},${start.lng}`,
                    point: `${end.lat},${end.lng}`,
                    vehicle: currentProfile === 'gravel' ? 'bike' : 'racingbike',
                    locale: 'de',
                    key: apiKeys.graphhopper,
                    elevation: 'true',
                    points_encoded: 'false',
                    'algorithm': 'alternative_route',
                    'alternative_route.max_paths': '3'
                });
                
                // Add elevation preference via custom model
                const customModel = { priority: [] };
                
                // For road bike: completely avoid unpaved surfaces
                if (currentProfile === 'road') {
                    customModel.priority.push(
                        { if: 'road_class == TRACK', multiply_by: 0 },
                        { if: 'road_class == PATH', multiply_by: 0 },
                        { if: 'surface == GRAVEL', multiply_by: 0 },
                        { if: 'surface == UNPAVED', multiply_by: 0 },
                        { if: 'surface == COMPACTED', multiply_by: 0 },
                        { if: 'surface == DIRT', multiply_by: 0 },
                        { if: 'surface == GROUND', multiply_by: 0 },
                        { if: 'surface == GRASS', multiply_by: 0 }
                    );
                }
                
                // Add elevation preferences
                if (currentElevationPref === 'flat') {
                    customModel.priority.push(
                        { if: 'max_slope > 5', multiply_by: 0.3 },
                        { if: 'max_slope > 10', multiply_by: 0.1 }
                    );
                } else if (currentElevationPref === 'hilly') {
                    customModel.priority.push(
                        { if: 'max_slope > 5', multiply_by: 1.5 },
                        { if: 'max_slope > 10', multiply_by: 2.0 }
                    );
                }
                
                // Apply custom model if we have rules
                if (customModel.priority.length > 0) {
                    params.append('ch.disable', 'true');
                    params.append('custom_model', JSON.stringify(customModel));
                }
                
                const response = await fetch(`${url}?${params.toString()}`);
                const data = await response.json();
                
                if (!data.paths || data.paths.length === 0) {
                    console.warn(`GraphHopper failed for segment ${segmentIndex + 1}`);
                    return null;
                }
                
                // Select best path based on elevation
                let bestPath = null;
                let bestScore = currentElevationPref === 'flat' ? Infinity : -Infinity;
                
                for (const path of data.paths) {
                    const elevationGain = path.ascend || 0;
                    
                    if (currentElevationPref === 'flat' && elevationGain < bestScore) {
                        bestScore = elevationGain;
                        bestPath = path;
                    } else if (currentElevationPref === 'hilly' && elevationGain > bestScore) {
                        bestScore = elevationGain;
                        bestPath = path;
                    }
                }
                
                if (!bestPath) {
                    bestPath = data.paths[0];
                }
                
                const path = bestPath;
                const coords = path.points.coordinates;
                const elevations = coords.map(c => c[2] || 0);
                
                console.log(`✓ GraphHopper (${currentElevationPref}: ${Math.round(bestScore)}m gain, ${data.paths.length} alternatives) → Segment ${segmentIndex + 1}`);
                
                return {
                    distance: path.distance,
                    coordinates: coords.map(c => [c[1], c[0]]),
                    geometry: coords,
                    elevations: elevations
                };
                
            } catch (error) {
                console.error(`GraphHopper error for segment ${segmentIndex + 1}:`, error);
                return null;
            }
        }
        
        async function getValhallaRoute(start, end, segmentIndex) {
            if (!apiKeys.valhalla) {
                console.log('⚠ Valhalla API key not set');
                return null;
            }
            
            try {
                const url = 'https://valhalla1.openstreetmap.de/route';
                const body = {
                    locations: [
                        { lat: start.lat, lon: start.lng },
                        { lat: end.lat, lon: end.lng }
                    ],
                    costing: currentProfile === 'gravel' ? 'bicycle' : 'bikeshare',
                    costing_options: {
                        bicycle: {
                            use_roads: currentProfile === 'road' ? 1.0 : 0.5,
                            use_hills: currentElevationPref === 'max' ? 1.0 : 
                                       currentElevationPref === 'min' ? 0.1 : 0.5
                        }
                    },
                    elevation: true
                };
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKeys.valhalla}`
                    },
                    body: JSON.stringify(body)
                });
                
                const data = await response.json();
                
                if (!data.trip || !data.trip.legs) {
                    console.warn(`Valhalla failed for segment ${segmentIndex + 1}`);
                    return null;
                }
                
                const leg = data.trip.legs[0];
                const coords = leg.shape.map(pt => [pt.lat, pt.lon]);
                const elevations = leg.shape.map(pt => pt.ele || 0);
                
                console.log(`✓ Valhalla (elev: ${currentElevationPref}) → Segment ${segmentIndex + 1}`);
                
                return {
                    distance: leg.summary.length * 1000,
                    coordinates: coords,
                    geometry: coords.map(c => [c[1], c[0]]),
                    elevations: elevations
                };
                
            } catch (error) {
                console.error(`Valhalla error for segment ${segmentIndex + 1}:`, error);
                return null;
            }
        }
        
        function reverseRoute() {
            waypoints.reverse();
            markers.forEach((m, i) => m.setLatLng([waypoints[i].lat, waypoints[i].lng]));
            updateList();
            clearRoutes();
        }
        
        function clearAll() {
            waypoints = [];
            markers.forEach(m => map.removeLayer(m));
            markers = [];
            clearRoutes();
            updateList();
            updateButtons();
        }
        
        function exportGPX() {
            if (!routes[0]) return;
            let gpx = `<?xml version="1.0"?>\n<gpx version="1.1">\n  <trk>\n    <trkseg>\n`;
            routes[0].coordinates.forEach(c => gpx += `      <trkpt lat="${c[0]}" lon="${c[1]}"/>\n`);
            gpx += `    </trkseg>\n  </trk>\n</gpx>`;
            const blob = new Blob([gpx], { type: 'application/gpx+xml' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'route.gpx';
            a.click();
        }
        
        function setProfile(p) {
            currentProfile = p;
            document.getElementById('gravelBtn').classList.toggle('active', p === 'gravel');
            document.getElementById('roadBtn').classList.toggle('active', p === 'road');
        }
        
        function setElevationPreference(pref) {
            currentElevationPref = pref;
            document.getElementById('flatElevBtn').classList.toggle('active', pref === 'flat');
            document.getElementById('hillyElevBtn').classList.toggle('active', pref === 'hilly');
            console.log(`✓ Elevation preference: ${pref}`);
        }
        
        function updateSpeed(v) {
            averageSpeed = parseInt(v);
            document.getElementById('speedValue').textContent = v + ' km/h';
        }
        
        // ========================================
        // ROUTE LIBRARY & HEATMAP FUNCTIONS
        // ========================================
        
        function setupRouteLibrary() {
            const libraryToggle = document.getElementById('libraryToggle');
            const routeLibrary = document.getElementById('routeLibrary');
            const libraryCloseBtn = document.getElementById('libraryCloseBtn');
            const heatmapToggle = document.getElementById('heatmapToggle');
            
            // Toggle library
            libraryToggle.addEventListener('click', () => {
                routeLibrary.classList.toggle('show');
            });
            
            // Close button
            libraryCloseBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                routeLibrary.classList.remove('show');
            });
            
            // Auto-transparency when mouse leaves
            routeLibrary.addEventListener('mouseenter', () => {
                routeLibrary.classList.remove('faded');
            });
            
            routeLibrary.addEventListener('mouseleave', () => {
                if (routeLibrary.classList.contains('show')) {
                    routeLibrary.classList.add('faded');
                }
            });
            
            heatmapToggle.addEventListener('click', toggleHeatmap);
            
            console.log('✓ Route library initialized');
        }
        
        function loadSavedRoutes() {
            const stored = localStorage.getItem('gravel_routes');
            if (stored) {
                try {
                    savedRoutes = JSON.parse(stored);
                    updateLibraryUI();
                    console.log(`✓ Loaded ${savedRoutes.length} saved routes`);
                } catch (e) {
                    console.error('Error loading routes:', e);
                    savedRoutes = [];
                }
            }
        }
        
        function promptSaveRoute() {
            if (routes.length === 0) return;
            
            const name = prompt('Route speichern als:', `Route ${new Date().toLocaleDateString()}`);
            if (name) {
                saveCurrentRoute(name);
            }
        }
        
        function saveCurrentRoute(name) {
            if (routes.length === 0) return;
            
            const route = routes[0];
            
            const savedRoute = {
                id: Date.now(),
                name: name,
                date: new Date().toISOString(),
                distance: route.distance,
                waypoints: waypoints.map(wp => ({ lat: wp.lat, lng: wp.lng })),
                coordinates: route.coordinates,
                elevations: route.elevations,
                stats: route.stats,
                count: 1,
                profile: currentProfile
            };
            
            // Check if similar route exists
            const existingIndex = savedRoutes.findIndex(r => 
                r.name === name && Math.abs(r.distance - savedRoute.distance) < 0.5
            );
            
            if (existingIndex >= 0) {
                // Increment count
                savedRoutes[existingIndex].count++;
                savedRoutes[existingIndex].date = new Date().toISOString();
            } else {
                savedRoutes.push(savedRoute);
            }
            
            localStorage.setItem('gravel_routes', JSON.stringify(savedRoutes));
            updateLibraryUI();
            
            console.log(`✓ Route "${name}" saved`);
            alert(`✓ Route "${name}" gespeichert!`);
        }
        
        function loadRoute(routeId) {
            const route = savedRoutes.find(r => r.id === routeId);
            if (!route) return;
            
            // Clear current
            clearAll();
            
            // Load waypoints
            route.waypoints.forEach(wp => {
                addWaypoint(wp.lat, wp.lng);
            });
            
            // Calculate route
            setTimeout(() => {
                calculateRoutes();
            }, 500);
            
            // Close library
            document.getElementById('routeLibrary').classList.remove('show');
            
            // Increment count
            const routeIndex = savedRoutes.findIndex(r => r.id === routeId);
            if (routeIndex >= 0) {
                savedRoutes[routeIndex].count++;
                localStorage.setItem('gravel_routes', JSON.stringify(savedRoutes));
                updateLibraryUI();
            }
            
            console.log(`✓ Loaded route: ${route.name}`);
        }
        
        function deleteRoute(routeId) {
            if (!confirm('Route wirklich löschen?')) return;
            
            savedRoutes = savedRoutes.filter(r => r.id !== routeId);
            localStorage.setItem('gravel_routes', JSON.stringify(savedRoutes));
            updateLibraryUI();
            
            console.log(`✓ Route deleted`);
        }
        
        function updateLibraryUI() {
            const routeList = document.getElementById('routeList');
            const totalRoutes = document.getElementById('totalRoutes');
            const totalDistance = document.getElementById('totalDistance');
            
            totalRoutes.textContent = savedRoutes.length;
            
            const sumDistance = savedRoutes.reduce((sum, r) => sum + (r.distance || 0), 0);
            totalDistance.textContent = sumDistance.toFixed(1) + ' km';
            
            if (savedRoutes.length === 0) {
                routeList.innerHTML = '<div style="padding: 10px; text-align: center; font-size: 11px; color: #94a3b8;">Noch keine Routen gespeichert</div>';
                return;
            }
            
            // Sort by count (most used first)
            const sorted = [...savedRoutes].sort((a, b) => (b.count || 1) - (a.count || 1));
            
            routeList.innerHTML = sorted.map(route => `
                <div class="route-item">
                    <div class="route-item-name">${route.name}</div>
                    <div class="route-item-stats">
                        <span>${route.distance.toFixed(1)} km</span>
                        <span class="route-item-count">×${route.count || 1}</span>
                    </div>
                    <div class="route-item-actions">
                        <button class="route-item-btn load" onclick="loadRoute(${route.id})">Laden</button>
                        <button class="route-item-btn delete" onclick="deleteRoute(${route.id})">×</button>
                    </div>
                </div>
            `).join('');
        }
        
        function toggleHeatmap() {
            const heatmapToggle = document.getElementById('heatmapToggle');
            
            if (heatmapLayer) {
                // Remove heatmap
                map.removeLayer(heatmapLayer);
                heatmapLayer = null;
                heatmapToggle.textContent = 'Heatmap anzeigen';
                heatmapToggle.classList.remove('active');
            } else {
                // Generate heatmap
                if (savedRoutes.length === 0) {
                    alert('Keine Routen zum Anzeigen. Speichere erst einige Routen!');
                    return;
                }
                
                const heatmapData = [];
                
                savedRoutes.forEach(route => {
                    const intensity = Math.min(route.count || 1, 10) / 10;
                    
                    route.coordinates.forEach((coord, idx) => {
                        // Sample every 10th point for performance
                        if (idx % 10 === 0) {
                            heatmapData.push([coord[0], coord[1], intensity]);
                        }
                    });
                });
                
                heatmapLayer = L.heatLayer(heatmapData, {
                    radius: 20,
                    blur: 25,
                    maxZoom: 17,
                    max: 1.0,
                    gradient: {
                        0.0: 'blue',
                        0.5: 'lime',
                        0.8: 'yellow',
                        1.0: 'red'
                    }
                }).addTo(map);
                
                heatmapToggle.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 12px; height: 12px; display: inline-block; vertical-align: middle;">
                        <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                    </svg>
                    Heatmap verbergen
                `;
                heatmapToggle.classList.add('active');
                
                console.log(`✓ Heatmap with ${heatmapData.length} points`);
            }
        }
        
        // ========================================
        // ELEVATION PROFILE FUNCTIONS
        // ========================================
        
        function showElevationProfile() {
            if (routes.length === 0 || !routes[0].elevations) return;
            
            const profile = document.getElementById('elevationProfile');
            profile.classList.add('show');
            
            const route = routes[0];
            const elevations = route.elevations;
            const coordinates = route.coordinates;
            
            // Calculate cumulative distance for each point
            const distances = [0];
            let totalDist = 0;
            
            for (let i = 1; i < coordinates.length; i++) {
                const prev = coordinates[i - 1];
                const curr = coordinates[i];
                
                // Haversine distance calculation
                const R = 6371; // Earth radius in km
                const lat1 = prev[0] * Math.PI / 180;
                const lat2 = curr[0] * Math.PI / 180;
                const dLat = (curr[0] - prev[0]) * Math.PI / 180;
                const dLon = (curr[1] - prev[1]) * Math.PI / 180;
                
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1) * Math.cos(lat2) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const dist = R * c; // Distance in km
                
                totalDist += dist;
                distances.push(totalDist);
            }
            
            console.log(`✓ Elevation profile: ${coordinates.length} coords, ${elevations.length} elevations, ${distances.length} distances`);
            console.log(`✓ Distance array: first=${distances[0].toFixed(2)}, last=${distances[distances.length-1].toFixed(2)}, total=${totalDist.toFixed(2)} km`);
            
            // Sample data for performance (max 200 points) but ensure full coverage
            const targetPoints = 200;
            const step = Math.max(1, Math.floor(elevations.length / targetPoints));
            const sampledElevations = [];
            const sampledDistances = [];
            const sampledGradients = [];
            
            // Sample points evenly across the entire route
            for (let i = 0; i < elevations.length; i += step) {
                const idx = Math.min(i, elevations.length - 1);
                sampledElevations.push(elevations[idx]);
                sampledDistances.push(distances[idx]);
                
                // Calculate gradient
                const nextIdx = Math.min(idx + step, elevations.length - 1);
                const prevIdx = Math.max(idx - step, 0);
                
                if (nextIdx > prevIdx && distances[nextIdx] && distances[prevIdx]) {
                    const elevDiff = elevations[nextIdx] - elevations[prevIdx];
                    const distDiff = (distances[nextIdx] - distances[prevIdx]) * 1000; // in meters
                    const gradient = distDiff > 0 ? (elevDiff / distDiff) * 100 : 0;
                    sampledGradients.push(gradient);
                } else {
                    sampledGradients.push(0);
                }
            }
            
            // CRITICAL: Always include the LAST point to reach full distance
            const lastIdx = elevations.length - 1;
            if (sampledDistances[sampledDistances.length - 1] < distances[lastIdx] - 0.1) {
                sampledElevations.push(elevations[lastIdx]);
                sampledDistances.push(distances[lastIdx]);
                sampledGradients.push(sampledGradients[sampledGradients.length - 1] || 0);
            }
            
            console.log(`✓ Sampled to ${sampledDistances.length} points, range: ${sampledDistances[0].toFixed(2)} - ${sampledDistances[sampledDistances.length - 1].toFixed(2)} km (target: ${totalDist.toFixed(2)} km)`);
            
            // Debug: Check elevation range
            const minElev = Math.min(...sampledElevations);
            const maxElev = Math.max(...sampledElevations);
            console.log(`✓ Elevation range: ${minElev.toFixed(0)}m - ${maxElev.toFixed(0)}m (${(maxElev - minElev).toFixed(0)}m difference)`);
            
            // Set Y-axis to start 50m below minimum elevation
            const yAxisMin = Math.max(0, minElev - 50);
            const yAxisMax = maxElev + 20; // Add 20m padding on top
            
            // Destroy old chart
            if (elevationChart) {
                elevationChart.destroy();
            }
            
            // Create gradient colors based on slope
            const backgroundColors = sampledGradients.map(g => {
                if (g > 8) return 'rgba(239, 68, 68, 0.8)';      // Steep up - red
                if (g > 4) return 'rgba(251, 146, 60, 0.8)';     // Moderate up - orange
                if (g > 0) return 'rgba(34, 197, 94, 0.8)';      // Gentle up - green
                if (g > -4) return 'rgba(59, 130, 246, 0.8)';    // Gentle down - blue
                if (g > -8) return 'rgba(147, 51, 234, 0.8)';    // Moderate down - purple
                return 'rgba(220, 38, 38, 0.8)';                 // Steep down - dark red
            });
            
            const ctx = document.getElementById('elevationChart').getContext('2d');
            
            // Find waypoint positions in the route
            const waypointDistances = [];
            waypoints.forEach((wp, wpIdx) => {
                let closestIdx = 0;
                let minDist = Infinity;
                
                // Find closest coordinate to this waypoint
                coordinates.forEach((coord, idx) => {
                    const dist = Math.sqrt(
                        Math.pow(coord[0] - wp.lat, 2) + 
                        Math.pow(coord[1] - wp.lng, 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = idx;
                    }
                });
                
                waypointDistances.push({
                    distance: distances[closestIdx],
                    index: wpIdx,
                    elevation: elevations[closestIdx]
                });
            });
            
            console.log('Waypoint positions:', waypointDistances.map(w => `WP${w.index + 1}: ${w.distance.toFixed(2)}km`).join(', '));
            
            // Create vertical line plugin for waypoints
            const waypointPlugin = {
                id: 'waypointLines',
                afterDatasetsDraw(chart) {
                    const { ctx, chartArea: { top, bottom }, scales: { x, y } } = chart;
                    
                    waypointDistances.forEach(wp => {
                        const xPos = x.getPixelForValue(wp.distance);
                        const wpColor = wp.index === 0 ? '#10b981' : 
                                       wp.index === waypoints.length - 1 ? '#ef4444' : '#3b82f6';
                        
                        // Draw thin solid vertical line
                        ctx.save();
                        ctx.strokeStyle = wpColor;
                        ctx.lineWidth = 1.5;
                        ctx.setLineDash([]);
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.moveTo(xPos, top);
                        ctx.lineTo(xPos, bottom);
                        ctx.stroke();
                        ctx.restore();
                        
                        // Draw flag marker at top of chart (inside chart area)
                        const flagSize = 8;
                        
                        ctx.save();
                        
                        // Draw circle flag
                        ctx.fillStyle = wpColor;
                        ctx.beginPath();
                        ctx.arc(xPos, top + 10, flagSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw white circle for number
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(xPos, top + 10, flagSize - 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw number
                        ctx.fillStyle = wpColor;
                        ctx.font = 'bold 9px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText((wp.index + 1).toString(), xPos, top + 10);
                        
                        ctx.restore();
                    });
                }
            };
            
            // Create surface background plugin (draws colored background in chart area)
            const surfacePlugin = {
                id: 'surfaceBackground',
                beforeDatasetsDraw(chart) {
                    // Only draw if surface chart toggle is active and data exists
                    const surfaceToggle = document.getElementById('toggleSurfaceChart');
                    if (!surfaceToggle || !surfaceToggle.classList.contains('active')) return;
                    if (!window.surfaceData || window.surfaceData.length === 0) return;
                    
                    const { ctx, chartArea: { left, right, top, bottom }, scales: { x } } = chart;
                    
                    // Surface color mapping (with transparency for background)
                    const surfaceColors = {
                        'paved': 'rgba(16, 185, 129, 0.15)',      // Green
                        'asphalt': 'rgba(16, 185, 129, 0.15)',   // Green
                        'compacted': 'rgba(234, 179, 8, 0.15)',  // Yellow
                        'gravel': 'rgba(249, 115, 22, 0.2)',     // Orange
                        'unpaved': 'rgba(239, 68, 68, 0.2)',     // Red
                        'dirt': 'rgba(220, 38, 38, 0.2)',        // Dark red
                        'ground': 'rgba(185, 28, 28, 0.2)',      // Very dark red
                        'sand': 'rgba(245, 158, 11, 0.15)',      // Amber
                        'unknown': 'rgba(148, 163, 184, 0.1)'    // Gray
                    };
                    
                    ctx.save();
                    
                    // Draw each segment as vertical colored stripe in background
                    const segmentWidth = (right - left) / window.surfaceData.length;
                    
                    window.surfaceData.forEach((surface, idx) => {
                        const color = surfaceColors[surface] || surfaceColors['unknown'];
                        const xStart = left + (idx * segmentWidth);
                        
                        // Fill from top to bottom of chart area
                        ctx.fillStyle = color;
                        ctx.fillRect(xStart, top, segmentWidth + 1, bottom - top);
                    });
                    
                    ctx.restore();
                }
            };
            
            elevationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Höhe (m)',
                        data: sampledDistances.map((dist, idx) => ({
                            x: dist,  // Use distance as x value directly
                            y: sampledElevations[idx]
                        })),
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 5,
                        segment: {
                            borderColor: ctx => {
                                // Check if surface toggle is active
                                const surfaceToggle = document.getElementById('toggleSurfaceChart');
                                if (!surfaceToggle || !surfaceToggle.classList.contains('active')) {
                                    // Default blue line when surface is off
                                    return '#3b82f6';
                                }
                                
                                // Get surface data for this segment
                                if (!window.surfaceData || window.surfaceData.length === 0) {
                                    return '#3b82f6';
                                }
                                
                                // Get X position (distance) for this point
                                const point = ctx.p0;
                                if (!point || !point.parsed) return '#3b82f6';
                                
                                const distance = point.parsed.x;  // Distance in km
                                const totalDistance = sampledDistances[sampledDistances.length - 1];
                                
                                // Map distance to surface data index
                                const surfaceIdx = Math.floor((distance / totalDistance) * window.surfaceData.length);
                                const clampedIdx = Math.min(surfaceIdx, window.surfaceData.length - 1);
                                const surface = window.surfaceData[clampedIdx] || 'unknown';
                                
                                // Surface color mapping (opaque for route line)
                                const surfaceColors = {
                                    'paved': '#10b981',      // Green
                                    'asphalt': '#10b981',    // Green
                                    'compacted': '#eab308',  // Yellow
                                    'gravel': '#f97316',     // Orange
                                    'unpaved': '#ef4444',    // Red
                                    'dirt': '#dc2626',       // Dark red
                                    'ground': '#b91c1c',     // Very dark red
                                    'sand': '#f59e0b',       // Amber
                                    'unknown': '#94a3b8'     // Gray
                                };
                                
                                return surfaceColors[surface] || surfaceColors['unknown'];
                            },
                            backgroundColor: ctx => {
                                const idx = ctx.p0DataIndex;
                                return backgroundColors[idx];
                            }
                        }
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 5,
                            right: 10,
                            bottom: 5,
                            left: 10
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    onHover: (event, activeElements, chart) => {
                        if (!activeElements || activeElements.length === 0) {
                            // Remove marker when mouse leaves
                            if (window.routeHoverMarker) {
                                map.removeLayer(window.routeHoverMarker);
                                window.routeHoverMarker = null;
                            }
                            return;
                        }
                        
                        // Get hovered point
                        const element = activeElements[0];
                        const dataIndex = element.index;
                        const distance = sampledDistances[dataIndex];
                        
                        // Find corresponding coordinate on route
                        // Calculate cumulative distances for all coordinates
                        if (!routes[0] || !routes[0].coordinates) return;
                        
                        const allCoordinates = routes[0].coordinates;
                        let cumulativeDist = 0;
                        let targetCoord = allCoordinates[0];
                        
                        for (let i = 1; i < allCoordinates.length; i++) {
                            const prev = allCoordinates[i - 1];
                            const curr = allCoordinates[i];
                            
                            // Haversine distance
                            const R = 6371;
                            const lat1 = prev[0] * Math.PI / 180;
                            const lat2 = curr[0] * Math.PI / 180;
                            const dLat = (curr[0] - prev[0]) * Math.PI / 180;
                            const dLon = (curr[1] - prev[1]) * Math.PI / 180;
                            
                            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                                     Math.cos(lat1) * Math.cos(lat2) *
                                     Math.sin(dLon/2) * Math.sin(dLon/2);
                            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                            const segmentDist = R * c;
                            
                            if (cumulativeDist + segmentDist >= distance) {
                                // Interpolate between prev and curr
                                const ratio = (distance - cumulativeDist) / segmentDist;
                                const lat = prev[0] + ratio * (curr[0] - prev[0]);
                                const lng = prev[1] + ratio * (curr[1] - prev[1]);
                                targetCoord = [lat, lng];
                                break;
                            }
                            
                            cumulativeDist += segmentDist;
                        }
                        
                        // Update or create marker
                        if (window.routeHoverMarker) {
                            window.routeHoverMarker.setLatLng(targetCoord);
                        } else {
                            window.routeHoverMarker = L.circleMarker(targetCoord, {
                                radius: 8,
                                fillColor: '#ef4444',
                                color: '#ffffff',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.9
                            }).addTo(map);
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: ctx => {
                                    return `${ctx[0].parsed.x.toFixed(2)} km`;
                                },
                                label: ctx => {
                                    const elev = ctx.parsed.y;
                                    const gradient = sampledGradients[ctx.dataIndex];
                                    return [
                                        `Höhe: ${elev.toFixed(0)} m`,
                                        `Steigung: ${gradient > 0 ? '+' : ''}${gradient.toFixed(1)}%`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Distanz (km)',
                                font: { size: 10 }
                            },
                            ticks: {
                                font: { size: 9 },
                                callback: function(value) {
                                    return value.toFixed(1);
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            min: 0,
                            max: totalDist
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Höhe (m)',
                                font: { size: 10 }
                            },
                            min: yAxisMin,
                            max: yAxisMax,
                            ticks: {
                                font: { size: 9 }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        }
                    }
                },
                plugins: [waypointPlugin, surfacePlugin]
            });
            
            console.log('✓ Elevation profile displayed with correct x-axis scale');
        }
        
        function hideElevationProfile() {
            document.getElementById('elevationProfile').classList.remove('show');
            if (elevationChart) {
                elevationChart.destroy();
                elevationChart = null;
            }
            if (surfaceChart) {
                surfaceChart.destroy();
                surfaceChart = null;
            }
        }
        
        // ========================================
        // SURFACE ANALYSIS FUNCTIONS
        // ========================================
        
        async function analyzeSurface(coordinates) {
            // Simplified surface analysis based on route type
            // In a real implementation, this would call OpenRouteService or similar
            
            // Sample coordinates for analysis (every 100m approx)
            const step = Math.max(1, Math.floor(coordinates.length / 50));
            const samples = [];
            
            for (let i = 0; i < coordinates.length; i += step) {
                samples.push(coordinates[i]);
            }
            
            // Generate surface data for each sampled point
            const surfaceTypes = [];
            const surfaceWeights = currentProfile === 'gravel' 
                ? { paved: 0.3, compacted: 0.2, gravel: 0.4, unpaved: 0.1 }
                : { paved: 0.85, compacted: 0.1, gravel: 0.04, unpaved: 0.01 };
            
            for (let i = 0; i < samples.length; i++) {
                const rand = Math.random();
                let cumulative = 0;
                let surface = 'paved';
                
                for (const [type, weight] of Object.entries(surfaceWeights)) {
                    cumulative += weight;
                    if (rand < cumulative) {
                        surface = type;
                        break;
                    }
                }
                
                surfaceTypes.push(surface);
            }
            
            // Store globally for surface chart
            window.surfaceData = surfaceTypes;
            
            // Estimate surface types based on profile and road types
            // This is a simplified version - real implementation would query OSM data
            let paved = 0;
            let gravel = 0;
            let trail = 0;
            
            if (currentProfile === 'gravel') {
                // Gravel profile prefers unpaved surfaces
                paved = 30 + Math.random() * 20;     // 30-50%
                gravel = 40 + Math.random() * 20;    // 40-60%
                trail = 100 - paved - gravel;         // remainder
            } else {
                // Road profile uses mainly paved
                paved = 70 + Math.random() * 20;     // 70-90%
                gravel = 10 + Math.random() * 10;    // 10-20%
                trail = 100 - paved - gravel;         // remainder
            }
            
            // Calculate difficulty score (0-100)
            const distance = routes[0].distance;
            const elevGain = routes[0].stats.elevationGain;
            const avgGradient = (elevGain / (distance * 1000)) * 100;
            
            let difficulty = 0;
            difficulty += Math.min(distance * 2, 40);          // Distance factor (max 40)
            difficulty += Math.min(avgGradient * 10, 30);      // Elevation factor (max 30)
            difficulty += (gravel * 0.2) + (trail * 0.3);      // Surface factor (max 30)
            
            return {
                paved: Math.round(paved),
                gravel: Math.round(gravel),
                trail: Math.round(trail),
                difficulty: Math.min(100, Math.round(difficulty)),
                gravelScore: Math.round(gravel + trail) // How much "gravel" content
            };
        }
        
        function getDifficultyLabel(score) {
            if (score < 30) return { label: 'Leicht', color: '#10b981', emoji: '🟢' };
            if (score < 50) return { label: 'Mittel', color: '#f59e0b', emoji: '🟡' };
            if (score < 70) return { label: 'Anspruchsvoll', color: '#f97316', emoji: '🟠' };
            return { label: 'Schwer', color: '#ef4444', emoji: '🔴' };
        }
        
        // ========================================
        // PROXIMITY FADING SYSTEM
        // ========================================
        
        function setupProximityFading() {
            const panels = [
                { element: document.getElementById('addressSearch'), threshold: 150 },
                { element: document.getElementById('poiToggle'), threshold: 150 },
                { element: document.getElementById('libraryToggle'), threshold: 150 }
            ];
            
            let mouseMoveTimeout;
            
            document.addEventListener('mousemove', (e) => {
                // Clear existing timeout
                clearTimeout(mouseMoveTimeout);
                
                // Throttle the updates
                mouseMoveTimeout = setTimeout(() => {
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    
                    panels.forEach(panel => {
                        if (!panel.element) return;
                        
                        // Skip if panel is not visible
                        const computedStyle = window.getComputedStyle(panel.element);
                        if (computedStyle.display === 'none') return;
                        
                        const rect = panel.element.getBoundingClientRect();
                        const panelCenterX = rect.left + rect.width / 2;
                        const panelCenterY = rect.top + rect.height / 2;
                        
                        // Calculate distance from mouse to panel center
                        const distance = Math.sqrt(
                            Math.pow(mouseX - panelCenterX, 2) + 
                            Math.pow(mouseY - panelCenterY, 2)
                        );
                        
                        // Apply fading based on distance
                        if (distance < panel.threshold) {
                            // Mouse is close - full opacity
                            panel.element.classList.remove('faded');
                        } else if (distance < panel.threshold + 100) {
                            // Transition zone - no change yet
                            // This creates a smooth buffer
                        } else {
                            // Mouse is far - fade out
                            panel.element.classList.add('faded');
                        }
                    });
                }, 50); // 50ms throttle for smooth performance
            });
            
            // Also check on scroll
            map.on('move', () => {
                clearTimeout(mouseMoveTimeout);
                mouseMoveTimeout = setTimeout(() => {
                    // On map movement, fade all panels briefly
                    panels.forEach(panel => {
                        if (panel.element && window.getComputedStyle(panel.element).display !== 'none') {
                            panel.element.classList.add('faded');
                        }
                    });
                }, 100);
            });
            
            console.log('✓ Proximity fading initialized');
        }
    </script>
</body>
</html>

